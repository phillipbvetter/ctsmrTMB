% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ctsmrTMB.R
\name{ctsmrTMB}
\alias{ctsmrTMB}
\title{Constructor for R6 ctsmrTMB class}
\value{
A model object of class 'ctsmrTMB'
}
\description{
Call ctsmrTMB$new() to construct a new instance of the class object
for specifying a new stochastic state space model.
}
\examples{

## ------------------------------------------------
## Method `ctsmrTMB$add_systems`
## ------------------------------------------------

# Specify Ornstein-Uhlenbeck Process
add_systems(dX ~ theta * (mu - X + u) * dt + sigma * dw)

# Specify Lokta-Volterra System of Equations
add_systems( dN ~ ( r * N * (1-N/K) - c*N*P/(N+Nbar) ) * dt + sigmaN * N * dw1,
             dP ~ ( eps*c*N*P/(N+Nbar) - mu * P ) * dt + sigmaP * P * dw2 )

## ------------------------------------------------
## Method `ctsmrTMB$add_observations`
## ------------------------------------------------

#Specify observation directly as a latent state
add_observations(y ~ x)

Specify observation as the sum of exponentials of two latent states
add_observations(y ~ exp(x1) + exp(x2))
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-ctsmrTMB-new}{\code{ctsmrTMB$new()}}
\item \href{#method-ctsmrTMB-add_systems}{\code{ctsmrTMB$add_systems()}}
\item \href{#method-ctsmrTMB-add_observations}{\code{ctsmrTMB$add_observations()}}
\item \href{#method-ctsmrTMB-add_observation_variances}{\code{ctsmrTMB$add_observation_variances()}}
\item \href{#method-ctsmrTMB-add_inputs}{\code{ctsmrTMB$add_inputs()}}
\item \href{#method-ctsmrTMB-add_parameters}{\code{ctsmrTMB$add_parameters()}}
\item \href{#method-ctsmrTMB-add_algebraics}{\code{ctsmrTMB$add_algebraics()}}
\item \href{#method-ctsmrTMB-add_constants}{\code{ctsmrTMB$add_constants()}}
\item \href{#method-ctsmrTMB-set_initial_state}{\code{ctsmrTMB$set_initial_state()}}
\item \href{#method-ctsmrTMB-set_lamperti}{\code{ctsmrTMB$set_lamperti()}}
\item \href{#method-ctsmrTMB-set_modelname}{\code{ctsmrTMB$set_modelname()}}
\item \href{#method-ctsmrTMB-set_cppfile_directory}{\code{ctsmrTMB$set_cppfile_directory()}}
\item \href{#method-ctsmrTMB-set_map}{\code{ctsmrTMB$set_map()}}
\item \href{#method-ctsmrTMB-get_parameters}{\code{ctsmrTMB$get_parameters()}}
\item \href{#method-ctsmrTMB-construct_nll}{\code{ctsmrTMB$construct_nll()}}
\item \href{#method-ctsmrTMB-estimate}{\code{ctsmrTMB$estimate()}}
\item \href{#method-ctsmrTMB-predict}{\code{ctsmrTMB$predict()}}
\item \href{#method-ctsmrTMB-print}{\code{ctsmrTMB$print()}}
\item \href{#method-ctsmrTMB-summary}{\code{ctsmrTMB$summary()}}
\item \href{#method-ctsmrTMB-plot}{\code{ctsmrTMB$plot()}}
\item \href{#method-ctsmrTMB-clone}{\code{ctsmrTMB$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ctsmrTMB-new"></a>}}
\if{latex}{\out{\hypertarget{method-ctsmrTMB-new}{}}}
\subsection{Method \code{new()}}{
Construct new ctsmrTMB model object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ctsmrTMB$new()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ctsmrTMB-add_systems"></a>}}
\if{latex}{\out{\hypertarget{method-ctsmrTMB-add_systems}{}}}
\subsection{Method \code{add_systems()}}{
Define and add multiple stochastic differential equation governing the process of individual state variables
on the form

\code{d<state> ~ f(t,<states>,<inputs>) * dt + g1(t,<states>,<inputs>) * dw1 
                                         + g2(t,<states>,<inputs>) * dw2 
                                           + ...}

where \code{f} is the drift, and \code{g1, g2, ...} are diffusions, with differential brownian motions dw1, dw2, ...
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ctsmrTMB$add_systems(form, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{form}}{formula specifying the stochastic differential equation to be added to the system.}

\item{\code{...}}{additional formulas similar to \code{form} for specifying multiple equations at once.}
}
\if{html}{\out{</div>}}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# Specify Ornstein-Uhlenbeck Process
add_systems(dX ~ theta * (mu - X + u) * dt + sigma * dw)

# Specify Lokta-Volterra System of Equations
add_systems( dN ~ ( r * N * (1-N/K) - c*N*P/(N+Nbar) ) * dt + sigmaN * N * dw1,
             dP ~ ( eps*c*N*P/(N+Nbar) - mu * P ) * dt + sigmaP * P * dw2 )
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ctsmrTMB-add_observations"></a>}}
\if{latex}{\out{\hypertarget{method-ctsmrTMB-add_observations}{}}}
\subsection{Method \code{add_observations()}}{
Define and add a relationship between an observed variable and system states. The observation equation
takes the form

\code{<observation> ~ h(t,<states>,<inputs>) + e)}

where \code{h} is the observation function, and \code{e} is normally distributed noise with zero mean and variance
to be specified. The observation variable should be present in the data provided when calling
\code{estimate(.data)} for parameter estimation.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ctsmrTMB$add_observations(form, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{form}}{formula class specifying the obsevation equation to be added to the system.}

\item{\code{...}}{additional formulas identical to \code{form} to specify multiple observation equations at a time.}
}
\if{html}{\out{</div>}}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{#Specify observation directly as a latent state
add_observations(y ~ x)

Specify observation as the sum of exponentials of two latent states
add_observations(y ~ exp(x1) + exp(x2))
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ctsmrTMB-add_observation_variances"></a>}}
\if{latex}{\out{\hypertarget{method-ctsmrTMB-add_observation_variances}{}}}
\subsection{Method \code{add_observation_variances()}}{
Specify the variance of an observation equation.

A defined observation variable \code{y} in e.g. \code{add_observations(y ~ 
h(t,<states>,<inputs>)} is pertubed by Gaussian noise with zero mean and variance
to-be specified using \code{add_observation_variances(y ~ p(t,<states>,<inputs>)}. We can
for instance declare \code{add_observation_variances(y ~ sigma_x^2} where \code{sigma_x}
is a fixed effect parameter to be declared through \code{add_parameters}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ctsmrTMB$add_observation_variances(form, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{form}}{formula class specifying the obsevation equation to be added to the system.}

\item{\code{...}}{additional formulas identical to \code{form} to specify multiple observation equations at a time.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ctsmrTMB-add_inputs"></a>}}
\if{latex}{\out{\hypertarget{method-ctsmrTMB-add_inputs}{}}}
\subsection{Method \code{add_inputs()}}{
Declare variables as data inputs

Declare whether a variable contained in system, observation or observation variance equations
is an input variable. If e.g. the system equation contains an input variable \code{u} then it
is declared using \code{add_inputs(u)}. The input data \code{u} must be contained in the
data.frame \code{data} when calling \code{estimate(data)} for parameter estimation.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ctsmrTMB$add_inputs(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{additional formulas identical to \code{form} to specify multiple observation equations at a time.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ctsmrTMB-add_parameters"></a>}}
\if{latex}{\out{\hypertarget{method-ctsmrTMB-add_parameters}{}}}
\subsection{Method \code{add_parameters()}}{
Declare variables as fixed effects and specify their initial value, lower and
upper bound used when calling the maximum likelihood optimization.

There are two ways to declare parameters. You can declare parameters using formulas i.e.
\code{add_parameters( theta ~ c(1,0,10), mu ~ c(0,-10,10) )}, where the values are initial,
lower and upper bound respectively. Alternatively you can provide a 3-column matrix where
rows corresponds to different parameters, and the parameter names are provided as rownames
of the matrix.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ctsmrTMB$add_parameters(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{formula whose left-hand side is the parameter name, and right hand side is a vector
of length 3 with inital value, lower and upper bound respectively. You can provide multiple
parameters at once by seperating formulas with comma.}

\item{\code{parameter.matrix}}{matrix of 3 columns where rows correspond to variables. The variable
names must be provided as rownames to the matrix. The columns are initial value, lower and
upper bound respectively.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ctsmrTMB-add_algebraics"></a>}}
\if{latex}{\out{\hypertarget{method-ctsmrTMB-add_algebraics}{}}}
\subsection{Method \code{add_algebraics()}}{
Add algebraic relations.

Algebraic relations is a convenient way to transform parameters in your equations.
In the Ornstein-Uhlenbeck process the rate parameter \code{theta} is always positive, so
estimation in the log-domain is a good idea. Instead of writing \code{exp(theta)} directly
in the system equation one can transform into the log domain using the algebraic relation
\code{add_algebraics(theta ~ exp(logtheta))}. All instances of \code{theta} is replaced
by \code{exp(logtheta)} when compiling the C++ function. Note that you must provide values
for \code{logtheta} now instead of \code{theta} when declaring parameters through
\code{add_parameters}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ctsmrTMB$add_algebraics(form, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{form}}{formula specifying the stochastic differential equation(s) to be added to the system.}

\item{\code{...}}{additional formulas similar to \code{form} for specifying multiple equations at once.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ctsmrTMB-add_constants"></a>}}
\if{latex}{\out{\hypertarget{method-ctsmrTMB-add_constants}{}}}
\subsection{Method \code{add_constants()}}{
Declare variables as scalar constants.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ctsmrTMB$add_constants(form, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{form}}{formula whose left-hand side is the constant variable name, and the right-hand side
is its numeric value.}

\item{\code{...}}{additional formulas similar to \code{form} for specifying multiple constants at once.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ctsmrTMB-set_initial_state"></a>}}
\if{latex}{\out{\hypertarget{method-ctsmrTMB-set_initial_state}{}}}
\subsection{Method \code{set_initial_state()}}{
Declare the initial state values i.e. mean and covariance for the system states.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ctsmrTMB$set_initial_state(mean, cov)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{mean}}{numeric vector of size equal to \code{n} (number of system states)}

\item{\code{cov}}{matrix (symmetric positive semi-definite) of dimensions \code{n^2}.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ctsmrTMB-set_lamperti"></a>}}
\if{latex}{\out{\hypertarget{method-ctsmrTMB-set_lamperti}{}}}
\subsection{Method \code{set_lamperti()}}{
Set a Lamperti Transformation

If the provided system equations have state dependent diffusion in of a few available ways
then it is advantageous to perform a transformation to remove the state dependence. This
comes at the cost of a more complicated drift function. The following types of state-dependence
is currently supported
\enumerate{
\item If no transformation is desired choose 'identity' (default).
\item If the diffusion term is proportional to x * dw, then a log-transform is available
\item If the diffusion term is proportional to x * (1-x) * dw, then a logit-transform is available
\item If the diffusion term is proportional to sqrt(x * (1-x)) * dw, then a sqrt-logit-transform
is available
\item If the diffusion term is proportional to x * (1-x^a) * dw, for a>0 then a power-logit
transform is available
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ctsmrTMB$set_lamperti(transform, states = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{transform}}{character vector - one of either "identity, "log", "logit", "sqrt-logit", or "power-logit"}

\item{\code{states}}{a vector of the state names for which the chosen transformation is desired. The
default (NULL) is to apply the transformation to all state equations.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ctsmrTMB-set_modelname"></a>}}
\if{latex}{\out{\hypertarget{method-ctsmrTMB-set_modelname}{}}}
\subsection{Method \code{set_modelname()}}{
Set modelname used to create the C++ file for TMB

When calling \code{TMB::MakeADFun} the (negative log) likelihood function is created in the
directory specified by the \code{set_cppfile_directory} method with name \code{<modelname>.cpp}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ctsmrTMB$set_modelname(name)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{string defining the model name.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ctsmrTMB-set_cppfile_directory"></a>}}
\if{latex}{\out{\hypertarget{method-ctsmrTMB-set_cppfile_directory}{}}}
\subsection{Method \code{set_cppfile_directory()}}{
Set the path directory where the constructed C++ file is created.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ctsmrTMB$set_cppfile_directory(directory)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{directory}}{string specifying the local path / directory}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ctsmrTMB-set_map"></a>}}
\if{latex}{\out{\hypertarget{method-ctsmrTMB-set_map}{}}}
\subsection{Method \code{set_map()}}{
Enable maximum a posterior (MAP) estimation.

Adds a maximum a posterior contribution to the (negative log) likelihood
function by evaluating the fixed effects parameters in a multivariate Gaussian
with \code{mean} and \code{covariance} as provided.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ctsmrTMB$set_map(mean, cov)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{mean}}{mean vector of the Gaussian prior parameter distribution}

\item{\code{cov}}{covariance matrix of the Gaussian prior parameter distribution}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ctsmrTMB-get_parameters"></a>}}
\if{latex}{\out{\hypertarget{method-ctsmrTMB-get_parameters}{}}}
\subsection{Method \code{get_parameters()}}{
Get initial (and estimated) parameters.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ctsmrTMB$get_parameters()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ctsmrTMB-construct_nll"></a>}}
\if{latex}{\out{\hypertarget{method-ctsmrTMB-construct_nll}{}}}
\subsection{Method \code{construct_nll()}}{
Construct and extract function handlers for the negative
log likelihood function.

The handlers from \code{TMB}'s \code{MakeADFun} are constructed and returned.
This enables the user to e.g. determine their own optimization algorithm to use
for estimation.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ctsmrTMB$construct_nll(
  data,
  ode.timestep = NULL,
  silence = FALSE,
  compile = FALSE,
  method = "ekf",
  loss = "quadratic",
  loss_c = 3
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data}}{data.frame containing time-vector 't', observations and inputs. The observations
can take \code{NA}-values.}

\item{\code{ode.timestep}}{numeric value. Sets the time step-size in numerical filtering schemes.
The defined step-size is used to calculate the number of steps between observation time-points as
defined by the provided \code{data}. If the calculated number of steps is larger than N.01 where N
is an integer, then the time-step is reduced such that exactly N+1 steps is taken between observations
The step-size is used in the two following ways depending on the
chosen method:
\enumerate{
\item Kalman filters: The time-step is used as the step-size in the
numerical Forward-Euler scheme to compute the prior state mean and
covariance estimate as the final time solution to the first and second
order moment differential equations.
\item TMB method: The time-step is used as the step-size in the Euler-Maruyama
scheme for simulating a sample path of the stochastic differential equation,
which serves to link together the latent (random effects) states.
}}

\item{\code{silence}}{boolean value. Sets the tracing information for \code{TMB::MakeADFun} in the
argument \code{silent} which disables outputs from the optimization algoritm during runtime.}

\item{\code{compile}}{boolean value. The default (\code{FALSE}) is to not compile the C++ objective
function but assume it is already compiled and corresponds to the specified model object. It is
the user's responsibility to ensure correspondence between the specified model and the precompiled
C++ object. If a precompiled C++ object is not found in the specified directory i.e.
in \code{<cppfile_directory>/<modelname>/(dll/so)} then the compile flag is set to \code{TRUE}.
If the user makes changes to system equations, observation equations, observation variances,
algebraic relations or lamperi transformations then the C++ object should be recompiled.}

\item{\code{method}}{character vector - one of either "ekf", "ukf" or "tmb". Sets the estimation
method. The package has three available methods implemented:
\enumerate{
\item The natural TMB-style formulation where latent states are considered random effects
and are integrated out using the Laplace approximation. This method only yields the gradient
of the (negative log) likelihood function with respect to the fixed effects for optimization.
The method is slower although probably has some precision advantages, and allows for non-Gaussian
observation noise (not yet implemented). One-step / K-step residuals are not yet available in
the package.
\item (Continous-Discrete) Extended Kalman Filter where the system dynamics are linearized
to handle potential non-linearities. This is computationally the fastest method.
\item (Continous-Discrete) Unscented Kalman Filter. This is a higher order non-linear Kalman Filter
which improves the mean and covariance estimates when the system display high nonlinearity, and
circumvents the necessity to compute the jacobian of the drift and observation functions.
}

All package features are currently available for the kalman filters, while TMB is limited to
parameter estimation. In particular, it is straight-forward to obtain k-step-ahead predictions
with these methods (use the \code{predict} S3 method), and stochastic simulation is also available
in the cases where long prediction horizons are sought, where the normality assumption will be
inaccurate.}

\item{\code{loss}}{character vector. Sets the loss function type (only implemented for the kalman filter
methods). The loss function is per default quadratic in the one-step residauls as is natural
when the Gaussian (negative log) likelihood is evaluated, but if the tails of the
distribution is considered too small i.e. outliers are weighted too much, then one
can choose loss functions that accounts for this. The three available types available:
\enumerate{
\item Quadratic loss (\code{quadratic}).
\item Quadratic-Linear (\code{huber})
\item Quadratic-Constant (\code{tukey})
}

The cutoff for the Huber and Tukey loss functions are determined from a provided cutoff
parameter \code{loss_c}. The implementations of these losses are approximations (pseudo-huber and sigmoid
approxmation respectively) for smooth derivatives.}

\item{\code{loss_c}}{cutoff value for huber and tukey loss functions. Defaults to \code{c=3}}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ctsmrTMB-estimate"></a>}}
\if{latex}{\out{\hypertarget{method-ctsmrTMB-estimate}{}}}
\subsection{Method \code{estimate()}}{
Estimate the fixed effects parameters in the specified model.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ctsmrTMB$estimate(
  data,
  use.hessian = FALSE,
  ode.timestep = NULL,
  silence = TRUE,
  compile = FALSE,
  method = "ekf",
  loss = "quadratic",
  loss_c = 3,
  control = list(trace = 1)
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data}}{data.frame containing time-vector 't', observations and inputs. The observations
can take \code{NA}-values.}

\item{\code{use.hessian}}{boolean value. The default (\code{TRUE}) causes the optimization algorithm
\code{stats::nlminb} to use the fixed effects hessian of the (negative log) likelihood when
performing the optimization. This feature is only available for the kalman filter methods
without any random effects.}

\item{\code{ode.timestep}}{numeric value. Sets the time step-size in numerical filtering schemes.
The defined step-size is used to calculate the number of steps between observation time-points as
defined by the provided \code{data}. If the calculated number of steps is larger than N.01 where N
is an integer, then the time-step is reduced such that exactly N+1 steps is taken between observations
The step-size is used in the two following ways depending on the
chosen method:
\enumerate{
\item Kalman filters: The time-step is used as the step-size in the
numerical Forward-Euler scheme to compute the prior state mean and
covariance estimate as the final time solution to the first and second
order moment differential equations.
\item TMB method: The time-step is used as the step-size in the Euler-Maruyama
scheme for simulating a sample path of the stochastic differential equation,
which serves to link together the latent (random effects) states.
}}

\item{\code{silence}}{boolean value. Sets the tracing information for \code{TMB::MakeADFun} in the
argument \code{silent} which disables outputs from the optimization algoritm during runtime.}

\item{\code{compile}}{boolean value. The default (\code{FALSE}) is to not compile the C++ objective
function but assume it is already compiled and corresponds to the specified model object. It is
the user's responsibility to ensure correspondence between the specified model and the precompiled
C++ object. If a precompiled C++ object is not found in the specified directory i.e.
in \code{<cppfile_directory>/<modelname>/(dll/so)} then the compile flag is set to \code{TRUE}.
If the user makes changes to system equations, observation equations, observation variances,
algebraic relations or lamperi transformations then the C++ object should be recompiled.}

\item{\code{method}}{character vector - one of either "ekf", "ukf" or "tmb". Sets the estimation
method. The package has three available methods implemented:
\enumerate{
\item The natural TMB-style formulation where latent states are considered random effects
and are integrated out using the Laplace approximation. This method only yields the gradient
of the (negative log) likelihood function with respect to the fixed effects for optimization.
The method is slower although probably has some precision advantages, and allows for non-Gaussian
observation noise (not yet implemented). One-step / K-step residuals are not yet available in
the package.
\item (Continous-Discrete) Extended Kalman Filter where the system dynamics are linearized
to handle potential non-linearities. This is computationally the fastest method.
\item (Continous-Discrete) Unscented Kalman Filter. This is a higher order non-linear Kalman Filter
which improves the mean and covariance estimates when the system display high nonlinearity, and
circumvents the necessity to compute the jacobian of the drift and observation functions.
}

All package features are currently available for the kalman filters, while TMB is limited to
parameter estimation. In particular, it is straight-forward to obtain k-step-ahead predictions
with these methods (use the \code{predict} S3 method), and stochastic simulation is also available
in the cases where long prediction horizons are sought, where the normality assumption will be
inaccurate.}

\item{\code{loss}}{character vector. Sets the loss function type (only implemented for the kalman filter
methods). The loss function is per default quadratic in the one-step residauls as is natural
when the Gaussian (negative log) likelihood is evaluated, but if the tails of the
distribution is considered too small i.e. outliers are weighted too much, then one
can choose loss functions that accounts for this. The three available types available:
\enumerate{
\item Quadratic loss (\code{quadratic}).
\item Quadratic-Linear (\code{huber})
\item Quadratic-Constant (\code{tukey})
}

The cutoff for the Huber and Tukey loss functions are determined from a provided cutoff
parameter \code{loss_c}. The implementations of these losses are approximations (pseudo-huber and sigmoid
approxmation respectively) for smooth derivatives.}

\item{\code{loss_c}}{cutoff value for huber and tukey loss functions. Defaults to \code{c=3}}

\item{\code{control}}{list of control parameters parsed to \code{nlminb} as its \code{control} argument.
See \code{?stats::nlminb} for more information}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ctsmrTMB-predict"></a>}}
\if{latex}{\out{\hypertarget{method-ctsmrTMB-predict}{}}}
\subsection{Method \code{predict()}}{
Perform prediction/filtration to obtain state mean and covariance estimates.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ctsmrTMB$predict(
  data = NULL,
  pars = NULL,
  k.ahead = 1,
  return.k.ahead = NULL,
  ode.timestep = NULL,
  compile = FALSE,
  method = "ekf",
  x0 = NULL,
  p0 = NULL,
  return.covariance = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data}}{data.frame containing time-vector 't', observations and inputs. The observations
can take \code{NA}-values.}

\item{\code{pars}}{fixed parameter vector parsed to the objective function for prediction/filtration. The default
parameter values used are the initial parameters provided through \code{add_parameters}, unless the \code{estimate}
function has been run, then the default values will be those at the found optimum.}

\item{\code{k.ahead}}{integer specifying the desired number of time-steps (as determined by the provided
data time-vector) for which predictions are made (integrating the moment ODEs forward in time without
data updates).}

\item{\code{return.k.ahead}}{numeric vector of integers specifying which n.ahead predictions to that
should be returned.}

\item{\code{ode.timestep}}{numeric value. Sets the time step-size in numerical filtering schemes.
The defined step-size is used to calculate the number of steps between observation time-points as
defined by the provided \code{data}. If the calculated number of steps is larger than N.01 where N
is an integer, then the time-step is reduced such that exactly N+1 steps is taken between observations
The step-size is used in the two following ways depending on the
chosen method:
\enumerate{
\item Kalman filters: The time-step is used as the step-size in the
numerical Forward-Euler scheme to compute the prior state mean and
covariance estimate as the final time solution to the first and second
order moment differential equations.
\item TMB method: The time-step is used as the step-size in the Euler-Maruyama
scheme for simulating a sample path of the stochastic differential equation,
which serves to link together the latent (random effects) states.
}}

\item{\code{compile}}{boolean value. The default (\code{FALSE}) is to not compile the C++ objective
function but assume it is already compiled and corresponds to the specified model object. It is
the user's responsibility to ensure correspondence between the specified model and the precompiled
C++ object. If a precompiled C++ object is not found in the specified directory i.e.
in \code{<cppfile_directory>/<modelname>/(dll/so)} then the compile flag is set to \code{TRUE}.
If the user makes changes to system equations, observation equations, observation variances,
algebraic relations or lamperi transformations then the C++ object should be recompiled.}

\item{\code{method}}{character vector - one of either "ekf", "ukf" or "tmb". Sets the estimation
method. The package has three available methods implemented:

ONLY EKF IS IMPLEMENTED CURRENTLY!!
\enumerate{
\item The natural TMB-style formulation where latent states are considered random effects
and are integrated out using the Laplace approximation. This method only yields the gradient
of the (negative log) likelihood function with respect to the fixed effects for optimization.
The method is slower although probably has some precision advantages, and allows for non-Gaussian
observation noise (not yet implemented). One-step / K-step residuals are not yet available in
the package.
\item (Continous-Discrete) Extended Kalman Filter where the system dynamics are linearized
to handle potential non-linearities. This is computationally the fastest method.
\item (Continous-Discrete) Unscented Kalman Filter. This is a higher order non-linear Kalman Filter
which improves the mean and covariance estimates when the system display high nonlinearity, and
circumvents the necessity to compute the jacobian of the drift and observation functions.
}

All package features are currently available for the kalman filters, while TMB is limited to
parameter estimation. In particular, it is straight-forward to obtain k-step-ahead predictions
with these methods (use the \code{predict} S3 method), and stochastic simulation is also available
in the cases where long prediction horizons are sought, where the normality assumption will be
inaccurate.}

\item{\code{x0}}{numeric vector containing the initial expected state values}

\item{\code{p0}}{numeric matrix contianing the initial state covariances}

\item{\code{return.covariance}}{booelan value to indicate whether the covariance (instead of the correlation)
should be returned.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ctsmrTMB-print"></a>}}
\if{latex}{\out{\hypertarget{method-ctsmrTMB-print}{}}}
\subsection{Method \code{print()}}{
Function to print the model object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ctsmrTMB$print()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ctsmrTMB-summary"></a>}}
\if{latex}{\out{\hypertarget{method-ctsmrTMB-summary}{}}}
\subsection{Method \code{summary()}}{
Summary function for fit
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ctsmrTMB$summary(correlation = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{correlation}}{boolean value. The default (\code{FALSE}) is to not provide the fixed effects parameter
correlation matrix.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ctsmrTMB-plot"></a>}}
\if{latex}{\out{\hypertarget{method-ctsmrTMB-plot}{}}}
\subsection{Method \code{plot()}}{
Function to print the model object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ctsmrTMB$plot(
  plot.obs = 1,
  use.ggplot = FALSE,
  extended = FALSE,
  ggtheme = getggplot2theme()
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{plot.obs}}{integer value. The value determines which state residual plot is shown, when the states are numbered
by the order in which they were defined in the model object.}

\item{\code{use.ggplot}}{boolean value. The default \code{FALSE} is to use base plots in R, if \code{TRUE} then \code{ggplot2}
is used to show and return a list of all residual state plots.}

\item{\code{extended}}{boolean value. No functionality yet.}

\item{\code{ggtheme}}{ggplot theme. This determines the theme used to construct the ggplot2 if \code{use.ggplot=TRUE}.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ctsmrTMB-clone"></a>}}
\if{latex}{\out{\hypertarget{method-ctsmrTMB-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{ctsmrTMB$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
