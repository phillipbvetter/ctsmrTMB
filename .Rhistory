data.frame(external=opt$par, internal=fit$par.fixed)
knitr::opts_chunk$set(echo = TRUE)
library(ctsmrTMB)
# Simulate data using Euler Maruyama
set.seed(10)
theta=10; mu=1; sigma_x=1; sigma_y=1e-2
#
dt.sim = 1e-3
t.sim = seq(0,1,by=dt.sim)
dw = rnorm(length(t.sim)-1,sd=sqrt(dt.sim))
x = 3
for(i in 1:(length(t.sim)-1)) {
x[i+1] = x[i] + theta*(mu-x[i])*dt.sim + sigma_x*dw[i]
}
# Extract observations and add noise
dt.obs = 1e-2
t.obs = seq(0,1,by=dt.obs)
y = x[t.sim %in% t.obs] + sigma_y * rnorm(length(t.obs))
# Create data
.data = data.frame(
t = t.obs,
y = y
)
# Create model object
obj = ctsmrTMB$new()
# Set name of model (and the created .cpp file)
obj$set_modelname("ornstein_uhlenbeck")
# Add system equations
obj$add_systems(
dx ~ theta * (mu-x) * dt + sigma_x*dw
)
# Add observation equations
obj$add_observations(
y ~ x
)
# Set observation equation variances
obj$add_observation_variances(
y ~ sigma_y^2
)
# Specify algebraic relations
obj$add_algebraics(
theta ~ exp(logtheta),
sigma_x ~ exp(logsigma_x),
sigma_y ~ exp(logsigma_y)
)
# Specify parameter initial values and lower/upper bounds in estimation
obj$add_parameters(
logtheta = log(c(init = 1, lower=1e-5, upper=50)),
mu = c(init=1.5, lower=0, upper=5),
logsigma_x = log(c(init= 1e-1, lower=1e-10, upper=10)),
logsigma_y = log(c(init=1e-1, lower=1e-10, upper=10))
)
# Set initial state mean and covariance
obj$set_initial_state(x[1], 1e-1*diag(1))
fit = obj$estimate(data=.data, method="ekf", ode.timestep=dt.sim)
# nll = TMB::MakeADFun(...)
# opt = nlminb(start=nll$par, objective=nll$fn, grad=nll$gr)
nll = obj$construct_nll(data=.data,
ode.timestep=dt.sim,
method="ekf",
compile=FALSE,
silence=TRUE,
loss="quadratic",
loss_c=3)
# Initial parameters
nll$par
# Function handler
nll$fn(nll$par)
# Gradient handler
nll$gr(nll$par)
# Hessian handler
nll$he(nll$par)
pars = obj$get_parameters()
print(pars)
opt = stats::optim(par=nll$par,
fn=nll$fn,
gr=nll$gr,
method="L-BFGS-B",
lower=pars$lower,
upper=pars$upper)
# Estimated parameters
data.frame(external=opt$par, internal=fit$par.fixed)
# Neg. Log-Likelihood
data.frame(external=opt$value, internal=fit$nll.value)
# Gradient components
data.frame(external=t(nll$gr(opt$par)), internal=t(nll$gr(fit$par.fixed)))
setwd("/Users/pbrve/github/ctsmrTMB")
library(pkgdown)
library(devtools)
library(usethis)
library(bslib)
# usethis::use_pkgdown()
devtools::document()
# pkgdown::clean_site()
pkgdown::build_site()
knitr::opts_chunk$set(echo = TRUE)
library(ctsmrTMB)
# Simulate data using Euler Maruyama
set.seed(10)
theta=10; mu=1; sigma_x=1; sigma_y=1e-2
#
dt.sim = 1e-3
t.sim = seq(0,1,by=dt.sim)
dw = rnorm(length(t.sim)-1,sd=sqrt(dt.sim))
x = 3
for(i in 1:(length(t.sim)-1)) {
x[i+1] = x[i] + theta*(mu-x[i])*dt.sim + sigma_x*dw[i]
}
# Extract observations and add noise
dt.obs = 1e-2
t.obs = seq(0,1,by=dt.obs)
y = x[t.sim %in% t.obs] + sigma_y * rnorm(length(t.obs))
# Create data
.data = data.frame(
t = t.obs,
y = y
)
# Create model object
obj = ctsmrTMB$new()
# Set name of model (and the created .cpp file)
obj$set_modelname("ornstein_uhlenbeck")
# Add system equations
obj$add_systems(
dx ~ theta * (mu-x) * dt + sigma_x*dw
)
# Add observation equations
obj$add_observations(
y ~ x
)
# Set observation equation variances
obj$add_observation_variances(
y ~ sigma_y^2
)
# Specify algebraic relations
obj$add_algebraics(
theta ~ exp(logtheta),
sigma_x ~ exp(logsigma_x),
sigma_y ~ exp(logsigma_y)
)
# Specify parameter initial values and lower/upper bounds in estimation
obj$add_parameters(
logtheta = log(c(init = 1, lower=1e-5, upper=50)),
mu = c(init=1.5, lower=0, upper=5),
logsigma_x = log(c(init= 1e-1, lower=1e-10, upper=10)),
logsigma_y = log(c(init=1e-1, lower=1e-10, upper=10))
)
# Set initial state mean and covariance
obj$set_initial_state(x[1], 1e-1*diag(1))
fit = obj$estimate(data=.data, method="ekf", ode.timestep=dt.sim)
# nll = TMB::MakeADFun(...)
# opt = nlminb(start=nll$par, objective=nll$fn, grad=nll$gr)
nll = obj$construct_nll(data=.data,
ode.timestep=dt.sim,
method="ekf",
compile=FALSE,
silence=TRUE,
loss="quadratic",
loss_c=3)
# Initial parameters
nll$par
# Function handler
nll$fn(nll$par)
# Gradient handler
nll$gr(nll$par)
# Hessian handler
nll$he(nll$par)
pars = obj$get_parameters()
print(pars)
opt = stats::optim(par=nll$par,
fn=nll$fn,
gr=nll$gr,
method="L-BFGS-B",
lower=pars$lower,
upper=pars$upper)
# Estimated parameters
data.frame(external=opt$par, internal=fit$par.fixed)
# Neg. Log-Likelihood
data.frame(external=opt$value, internal=fit$nll.value)
# Gradient components
data.frame(external=t(nll$gr(opt$par)), internal=t(nll$gr(fit$par.fixed)))
setwd("/Users/pbrve/github/ctsmrTMB")
library(pkgdown)
library(devtools)
library(usethis)
library(bslib)
# usethis::use_pkgdown()
devtools::document()
# pkgdown::clean_site()
pkgdown::build_site()
knitr::opts_chunk$set(echo = TRUE)
library(ctsmrTMB)
# Simulate data using Euler Maruyama
set.seed(10)
theta=10; mu=1; sigma_x=1; sigma_y=1e-2
#
dt.sim = 1e-3
t.sim = seq(0,1,by=dt.sim)
dw = rnorm(length(t.sim)-1,sd=sqrt(dt.sim))
x = 3
for(i in 1:(length(t.sim)-1)) {
x[i+1] = x[i] + theta*(mu-x[i])*dt.sim + sigma_x*dw[i]
}
# Extract observations and add noise
dt.obs = 1e-2
t.obs = seq(0,1,by=dt.obs)
y = x[t.sim %in% t.obs] + sigma_y * rnorm(length(t.obs))
# Create data
.data = data.frame(
t = t.obs,
y = y
)
# Create model object
obj = ctsmrTMB$new()
# Set name of model (and the created .cpp file)
obj$set_modelname("ornstein_uhlenbeck")
# Add system equations
obj$add_systems(
dx ~ theta * (mu-x) * dt + sigma_x*dw
)
# Add observation equations
obj$add_observations(
y ~ x
)
# Set observation equation variances
obj$add_observation_variances(
y ~ sigma_y^2
)
# Specify algebraic relations
obj$add_algebraics(
theta ~ exp(logtheta),
sigma_x ~ exp(logsigma_x),
sigma_y ~ exp(logsigma_y)
)
# Specify parameter initial values and lower/upper bounds in estimation
obj$add_parameters(
logtheta = log(c(init = 1, lower=1e-5, upper=50)),
mu = c(init=1.5, lower=0, upper=5),
logsigma_x = log(c(init= 1e-1, lower=1e-10, upper=10)),
logsigma_y = log(c(init=1e-1, lower=1e-10, upper=10))
)
# Set initial state mean and covariance
obj$set_initial_state(x[1], 1e-1*diag(1))
fit = obj$estimate(data=.data,
method="ekf",
ode.timestep=dt.sim,
silence=TRUE)
# nll = TMB::MakeADFun(...)
# opt = nlminb(start=nll$par, objective=nll$fn, grad=nll$gr)
nll = obj$construct_nll(data=.data,
ode.timestep=dt.sim,
method="ekf",
compile=FALSE,
silence=TRUE,
loss="quadratic",
loss_c=3)
# Initial parameters
nll$par
# Function handler
nll$fn(nll$par)
# Gradient handler
nll$gr(nll$par)
# Hessian handler
nll$he(nll$par)
pars = obj$get_parameters()
print(pars)
opt = stats::optim(par=nll$par,
fn=nll$fn,
gr=nll$gr,
method="L-BFGS-B",
lower=pars$lower,
upper=pars$upper)
# Estimated parameters
data.frame(external=opt$par, internal=fit$par.fixed)
# Neg. Log-Likelihood
data.frame(external=opt$value, internal=fit$nll.value)
# Gradient components
data.frame(external=t(nll$gr(opt$par)), internal=t(nll$gr(fit$par.fixed)))
?ctsmrTMB
knitr::opts_chunk$set(echo = TRUE)
library(ctsmrTMB)
# Simulate data using Euler Maruyama
set.seed(10)
theta=10; mu=1; sigma_x=1; sigma_y=1e-2
#
dt.sim = 1e-3
t.sim = seq(0,1,by=dt.sim)
dw = rnorm(length(t.sim)-1,sd=sqrt(dt.sim))
x = 3
for(i in 1:(length(t.sim)-1)) {
x[i+1] = x[i] + theta*(mu-x[i])*dt.sim + sigma_x*dw[i]
}
# Extract observations and add noise
dt.obs = 1e-2
t.obs = seq(0,1,by=dt.obs)
y = x[t.sim %in% t.obs] + sigma_y * rnorm(length(t.obs))
# Create data
.data = data.frame(
t = t.obs,
y = y
)
# Create model object
obj = ctsmrTMB$new()
# Set name of model (and the created .cpp file)
obj$set_modelname("ornstein_uhlenbeck")
# Add system equations
obj$add_systems(
dx ~ theta * (mu-x) * dt + sigma_x*dw
)
# Add observation equations
obj$add_observations(
y ~ x
)
# Set observation equation variances
obj$add_observation_variances(
y ~ sigma_y^2
)
# Specify algebraic relations
obj$add_algebraics(
theta ~ exp(logtheta),
sigma_x ~ exp(logsigma_x),
sigma_y ~ exp(logsigma_y)
)
# Specify parameter initial values and lower/upper bounds in estimation
obj$add_parameters(
logtheta = log(c(init = 1, lower=1e-5, upper=50)),
mu = c(init=1.5, lower=0, upper=5),
logsigma_x = log(c(init= 1e-1, lower=1e-10, upper=10)),
logsigma_y = log(c(init=1e-1, lower=1e-10, upper=10))
)
# Set initial state mean and covariance
obj$set_initial_state(x[1], 1e-1*diag(1))
fit = obj$estimate(data=.data,
method="ekf",
ode.timestep=dt.sim,
silence=TRUE)
# nll = TMB::MakeADFun(...)
# opt = nlminb(start=nll$par, objective=nll$fn, grad=nll$gr)
nll = obj$construct_nll(data=.data,
ode.timestep=dt.sim,
method="ekf",
compile=FALSE,
silence=TRUE,
loss="quadratic",
loss_c=3)
# Initial parameters
nll$par
# Function handler
nll$fn(nll$par)
# Gradient handler
nll$gr(nll$par)
# Hessian handler
nll$he(nll$par)
pars = obj$get_parameters()
print(pars)
opt = stats::optim(par=nll$par,
fn=nll$fn,
gr=nll$gr,
method="L-BFGS-B",
lower=pars$lower,
upper=pars$upper)
# Estimated parameters
data.frame(external=opt$par, internal=fit$par.fixed)
# Neg. Log-Likelihood
data.frame(external=opt$value, internal=fit$nll.value)
# Gradient components
data.frame(external=t(nll$gr(opt$par)), internal=t(nll$gr(fit$par.fixed)))
fit = obj$estimate(data=.data,
method="ekf",
ode.timestep=dt.sim,
silence=FALSE)
fit = obj$estimate(data=.data,
method="ekf",
ode.timestep=dt.sim,
silence=TRUE)
?ctsmrTMB
fit = obj$estimate(data=.data,
method="ekf",
ode.timestep=dt.sim,
silence=TRUE,
control=list(trace=0))
fit = obj$estimate(data=.data,
method="ekf",
ode.timestep=dt.sim,
silence=TRUE,
control=list(trace=0))
fit = obj$estimate(data=.data,
method="ekf",
ode.timestep=dt.sim,
silence=FALSE,
control=list(trace=0))
5+5
10+10
25+25
setwd("/Users/pbrve/github/ctsmrTMB")
library(pkgdown)
library(devtools)
library(usethis)
library(bslib)
# usethis::use_pkgdown()
devtools::document()
# pkgdown::clean_site()
pkgdown::build_site()
knitr::opts_chunk$set(echo = TRUE)
library(ctsmrTMB)
# Simulate data using Euler Maruyama
set.seed(10)
theta=10; mu=1; sigma_x=1; sigma_y=1e-2
#
dt.sim = 1e-3
t.sim = seq(0,1,by=dt.sim)
dw = rnorm(length(t.sim)-1,sd=sqrt(dt.sim))
x = 3
for(i in 1:(length(t.sim)-1)) {
x[i+1] = x[i] + theta*(mu-x[i])*dt.sim + sigma_x*dw[i]
}
# Extract observations and add noise
dt.obs = 1e-2
t.obs = seq(0,1,by=dt.obs)
y = x[t.sim %in% t.obs] + sigma_y * rnorm(length(t.obs))
# Create data
.data = data.frame(
t = t.obs,
y = y
)
# Create model object
obj = ctsmrTMB$new()
# Set name of model (and the created .cpp file)
obj$set_modelname("ornstein_uhlenbeck")
# Add system equations
obj$add_systems(
dx ~ theta * (mu-x) * dt + sigma_x*dw
)
# Add observation equations
obj$add_observations(
y ~ x
)
# Set observation equation variances
obj$add_observation_variances(
y ~ sigma_y^2
)
# Specify algebraic relations
obj$add_algebraics(
theta ~ exp(logtheta),
sigma_x ~ exp(logsigma_x),
sigma_y ~ exp(logsigma_y)
)
# Specify parameter initial values and lower/upper bounds in estimation
obj$add_parameters(
logtheta = log(c(init = 1, lower=1e-5, upper=50)),
mu = c(init=1.5, lower=0, upper=5),
logsigma_x = log(c(init= 1e-1, lower=1e-10, upper=10)),
logsigma_y = log(c(init=1e-1, lower=1e-10, upper=10))
)
# Set initial state mean and covariance
obj$set_initial_state(x[1], 1e-1*diag(1))
fit = obj$estimate(data=.data,
method="ekf",
ode.timestep=dt.sim,
silence=TRUE,
control=list(trace=0))
# nll = TMB::MakeADFun(...)
# opt = nlminb(start=nll$par, objective=nll$fn, grad=nll$gr)
nll = obj$construct_nll(data=.data,
ode.timestep=dt.sim,
method="ekf",
compile=FALSE,
silence=TRUE,
loss="quadratic",
loss_c=3)
# Initial parameters
nll$par
# Function handler
nll$fn(nll$par)
# Gradient handler
nll$gr(nll$par)
# Hessian handler
nll$he(nll$par)
pars = obj$get_parameters()
print(pars)
opt = stats::optim(par=nll$par,
fn=nll$fn,
gr=nll$gr,
method="L-BFGS-B",
lower=pars$lower,
upper=pars$upper)
# Estimated parameters
data.frame(external=opt$par, internal=fit$par.fixed)
# Neg. Log-Likelihood
data.frame(external=opt$value, internal=fit$nll.value)
# Gradient components
data.frame(external=t(nll$gr(opt$par)), internal=t(nll$gr(fit$par.fixed)))
?ctsmrTMB
# Chunk 1: ctsmrTMB build documentation website
setwd("/Users/pbrve/github/ctsmrTMB")
library(pkgdown)
library(devtools)
library(usethis)
library(bslib)
# usethis::use_pkgdown()
devtools::document()
# pkgdown::clean_site()
pkgdown::build_site()
setwd("/Users/pbrve/github/ctsmrTMB")
library(pkgdown)
library(devtools)
library(usethis)
library(bslib)
# usethis::use_pkgdown()
devtools::document()
# pkgdown::clean_site()
pkgdown::build_site()
remotes::install_github(repo="phillipbvetter/ctsmrTMB", dependencies=TRUE)
