---
title: "Getting Started"
author: ""
date: ""
output: html_document
---

Let's get starting using `ctsmrTMB`!

We shall assume that you have some time series `data`, and a stochastic differential equation model which you believe can be used to model that data (or some latent variable that can be linked to your data). 

Here we consider the Ornstein-Uhlenbeck process
$$ 
\mathrm{d}X_{t} = \theta (\mu - X_{t}) \, \mathrm{d}t \, + \sigma_{X} \, \mathrm{d}B_{t} 
$$
where $\theta$, $\mu$ and $\sigma_x$ are (fixed effects) parameters in the model to be estimated. 

We assume that we have direct observations of the state $X_{t}$ i.e. the observation equation is
$$
Y_{t_{i}} = X_{t_{i}} + \varepsilon \qquad \varepsilon_{t_{i}} \sim \mathcal{N}(0,\sigma_{Y}^{2}*U_{t_{i}})
$$
and the residuals are normally distributed with variance $\sigma_{Y}^{2} \cdot U_{t}$, where $\sigma_{Y}$ is a fixed effect (parameter) which should also be estimated, and $U_{t}$ is an input. The input is added purely for the sake of this example. It could for instance be a vector 
$$
U_{t_{i}} = \left\{ 1,2,1,2,1,2,\cdots \right\}
$$
so that some observations have a larger variance than others, i.e. we believe them to be a less accurate measurement of $Y$.

# Initialising

---

We initialise a `ctsmrTMB` model object using
```{r}
library(ctsmrTMB)
obj = ctsmrTMB$new()
```

We can print the object to see what kind of model it contains
```{r}
print(obj)
```

We see that the model is called `sde_model` (default), and there are no states, diffusions, observations, inputs or parameters currently registered. The name is used to name the `C++` file that will be created locally, and to later recognize the compiled model object.

# Add system equations

---

We can begin by adding the desired stochastic differential equation to the object.
```{r}
obj$add_systems(dX ~ theta * (mu - X) * dt + sigma_x * dw)
```
We note that the drift term ends with `*dt` and diffusions are specified by `dw` or `dw#` where # can be any sequence of numbers.

# Add observation equations

---

We must also add the observation equation.
```{r}
obj$add_observations(Y ~ X)
```

The observations associated with `Y` in the `data` should also be named `Y`. 

# Add observation variances

---

For every observation variable we must also specify the variance of the normally distributed residuals for that observation equation
```{r}
obj$add_observation_variances(Y ~ sigma_y^2*U)
```
The variable name on the left-hand side of the formula must match a name previously defined via `add_observations`, and the variance is associated with that observation equation.

Let's inspect the model object again
```{r}
print(obj)
```
So now we have specified one state $X$ and an observation $Y$. The diffusions count the number of $\mathrm{d}\omega$ terms (a single equation can have multiple diffusion terms i.e. `sigma_1 * dw1 + sigma_2*dw2`). We also notice that there are no inputs and no parameter specified yet.

# Add inputs

---

We tell the model which variable names are inputs via
```{r}
obj$add_inputs(U)
```
The input values should be provided in the `data`, with the same name, similarly to the observations.


# Add parameters

---

We must also specify the (fixed effects) parameters, together with their initial value and lower and upper bound during optimization.
```{r}
obj$add_parameters(
  theta = c(initial=5, lower=0, upper=10),
  mu = c(initial=0, lower=-10, upper=10),
  sigma_x = c(initial = 1e-1, lower=1e-5, upper=1),
  sigma_y = c(initial = 1e-1, lower=1e-5, upper=1)
)
```

We can fix a parameter value (so the parameter becomes a constant) by supplying just a single value. It is usually difficult to seperate both noise parameters in practice, so lets say we want to fix $\sigma_{Y}$
```{r}
obj$add_parameters(
  sigma_y  = 1e-1
)
```

Let's inspect the model object again, and see that inputs and parameters (both non-fixed and fixed) have been registered.
```{r}
print(obj)
```

# Set initial state and covariance

---

The last thing to do before we can perform estimation is to set the initial value of the state(s) and its associated (co)variance. These two inputs are adequate since we assume a normally distributed state. The choice of value should reflect ones belief in the initial state, but it is most often a ballpark figure.
```{r}
obj$set_initial_state(mean=1, cov=1e-1*diag(1))
```
Note that we use `diag` to construct a 1x1 matrix for the covariance, as required by the method.


# Fit model parameters to data

---

We are now ready to perform state filtration and parameter estimation. This is carried out using the `estimate` method. We construct some fake data first
```{r, include=TRUE}
data = data.frame(
    t = 1:10,
    Y = 1:10 + rnorm(10),
    U = rep(c(1,2),times=5)
  )
```

The data must contain a time column named `t` and columns for each of the specified inputs and observations. We pass that data to `estimate`.

```{r}
# obj$estimate(data)
```








# Add algebraic relations / equations

---

For the sake of clarity it can sometimes be easier to specify simple variables in the equations in place of some other (perhaps larger) expression. We can redefine a variable name by providing an algebraic relation.

Let's say that we wish only to consider positive values of the parameter $\theta$, then it is appropriate to estimate in the log-domain (since the domain of the logarithm is the positive real axis). We use $\theta = \exp\left(\log\theta\right)$ and introduce the parameter `logtheta` to replace `theta`. This is obviously just names, and you might as well have written `exp(theta)` directly when specifying the system equations, but calling the parameter `logtheta` reminds one that we are really interested in the exponential of the parameter.

We specify the algebraic relation like so:
```{r}
obj$add_algebraics(theta ~ exp(logtheta))
```

When we change parameters like this, it is best to do it before calling `add_parameters` since we must now redefine the parameter values for `logtheta` as this is not done automatically.

```{r}
obj$add_parameters(logtheta = log(c(initial=5, lower=0, upper=10)))
```

