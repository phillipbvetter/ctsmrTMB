[{"path":[]},{"path":"/TODO.html","id":"prediction-function-without-data-update","dir":"","previous_headings":"","what":"Prediction function without data update","title":"add_parameters","text":"moment diff eqs simulation (stochastic!)","code":""},{"path":[]},{"path":"/TODO.html","id":null,"dir":"","previous_headings":"","what":"add_parameters","title":"add_parameters","text":"doesnt remove fixed parameter recalling add_parameters without NA’s. need update ","code":""},{"path":[]},{"path":"/articles/construct_nll.html","id":"simulate-from-the-ornstein-uhlenbeck-process","dir":"Articles","previous_headings":"","what":"Simulate from the Ornstein-Uhlenbeck process","title":"construct_nll: How to extract function handlers, and choosing your own optimizer","text":"use common Ornstein-Uhlenbeck process showcase use construct_nll. \\[ \\mathrm{d}X_{t} = \\theta (\\mu - X_{t}) \\, \\mathrm{d}t \\, + \\sigma_{X} \\, \\mathrm{d}B_{t} \\] \\[ Y_{t_{k}} = X_{t_{k}} + e_{t_{k}}, \\qquad e_{t_{k}} \\sim \\mathcal{N}\\left(0,\\sigma_{Y}^{2}\\right)   \\] first create data simulating process","code":"# Simulate data using Euler Maruyama set.seed(10) theta=10; mu=1; sigma_x=1; sigma_y=1e-1 #  dt.sim = 1e-3 t.sim = seq(0,1,by=dt.sim) dw = rnorm(length(t.sim)-1,sd=sqrt(dt.sim)) x = 3 for(i in 1:(length(t.sim)-1)) {   x[i+1] = x[i] + theta*(mu-x[i])*dt.sim + sigma_x*dw[i] }  # Extract observations and add noise dt.obs = 1e-2 t.obs = seq(0,1,by=dt.obs) y = x[t.sim %in% t.obs] + sigma_y * rnorm(length(t.obs))  # Create data .data = data.frame(   t = t.obs,   y = y )"},{"path":"/articles/construct_nll.html","id":"construct-model-object","dir":"Articles","previous_headings":"","what":"Construct model object","title":"construct_nll: How to extract function handlers, and choosing your own optimizer","text":"now construct ctsmrTMB model object","code":"# Create model object obj = ctsmrTMB$new()  # Set name of model (and the created .cpp file) obj$set_modelname(\"ornstein_uhlenbeck\")  # Add system equations obj$add_systems(   dx ~ theta * (mu-x) * dt + sigma_x*dw )  # Add observation equations obj$add_observations(   y ~ x )  # Set observation equation variances obj$add_observation_variances(   y ~ sigma_y^2 )  # Specify algebraic relations obj$add_algebraics(   theta ~ exp(logtheta),   sigma_x ~ exp(logsigma_x),   sigma_y ~ exp(logsigma_y) )  # Specify parameter initial values and lower/upper bounds in estimation obj$add_parameters(   logtheta   = log(c(initial = 5,    lower = 0,    upper = 20)),   mu         = c(    initial = 0,    lower = -10,  upper = 10),   logsigma_x = log(c(initial = 1e-1, lower = 1e-5, upper = 5)),   logsigma_y = log(c(initial = 1e-1, lower = 1e-5, upper = 5)) )  # Set initial state mean and covariance obj$set_initial_state(x[1], 1e-1*diag(1))"},{"path":"/articles/construct_nll.html","id":"estimation","dir":"Articles","previous_headings":"","what":"Estimation","title":"construct_nll: How to extract function handlers, and choosing your own optimizer","text":"principle ready call estimate method run optimization scheme using built-optimization uses stats::nlminb .e. Inside package optimise objective function respect fixed parameters using construction function handlers TMB::MakeADFun parsing stats::nlminb .e.","code":"fit = obj$estimate(.data) ## Building model... ## Checking data... ## Constructing objective function... ## Minimizing the negative log-likelihood... ##   0:     930.73050:  1.60944  0.00000 -2.30259 -2.30259 ##   1:     70.248169:  1.05183 0.613330 -1.83400 -1.99708 ##   2:     29.602641:  1.45881 0.575525 -1.50911 -1.14421 ##   3:     24.732671:  1.20511  1.44342 -1.23341 -1.47039 ##   4:    -1.1286877:  1.16623  1.06984 -0.911892 -1.54490 ##   5:    -32.058935:  1.64432 0.892949 0.470685 -2.57793 ##   6:    -33.437025:  1.68925 0.887873 0.310979 -2.58518 ##   7:    -35.579156:  2.09742 0.831411 0.244846 -2.33462 ##   8:    -37.076512:  2.45028  1.06678 0.130173 -2.12515 ##   9:    -38.409161:  2.58061  1.05353 0.0198337 -2.27669 ##  10:    -38.555050:  2.59126  1.07710 0.0690881 -2.26168 ##  11:    -38.613002:  2.64735  1.06588 0.0742325 -2.26633 ##  12:    -38.649388:  2.64092  1.05995 0.105687 -2.31381 ##  13:    -38.664984:  2.69128  1.08376 0.111913 -2.32715 ##  14:    -38.677982:  2.68296  1.07683 0.129108 -2.31547 ##  15:    -38.680142:  2.68022  1.07625 0.121336 -2.31668 ##  16:    -38.680159:  2.68121  1.07671 0.121685 -2.31678 ##  17:    -38.680159:  2.68112  1.07667 0.121666 -2.31675 ##  18:    -38.680159:  2.68112  1.07667 0.121665 -2.31675 ##   Optimization finished!: ##             Elapsed time: 0.003 seconds. ##             The objetive value is: -3.868016e+01 ##             The maximum gradient component is: 3.1e-06 ##             The convergence message is: relative convergence (4) ##             Iterations: 18 ##             Evaluations: Fun: 24 Grad: 19 ##             See stats::nlminb for available tolerance/control arguments. nll = TMB::MakeADFun(...) opt = nlminb(start=nll$par, objective=nll$fn, grad=nll$gr, hessian=nll$he)"},{"path":"/articles/construct_nll.html","id":"extract-function-handlers","dir":"Articles","previous_headings":"","what":"Extract function handlers","title":"construct_nll: How to extract function handlers, and choosing your own optimizer","text":"construct_nll method allows retrieve nll object. function takes arguments similar estimate. initial parameters (supplied user) stored objective function can evaluted gradient can evaluted hessian can evaluted can now use optimize function using e.g. stats::optim instead.","code":"nll = obj$construct_nll(.data) ## Building model... ## Checking data... ## Constructing objective function... ## Succesfully returned function handlers nll$par ##   logtheta         mu logsigma_x logsigma_y  ##   1.609438   0.000000  -2.302585  -2.302585 nll$fn(nll$par) ## [1] 930.7305 nll$gr(nll$par) ##          [,1]      [,2]      [,3]      [,4] ## [1,] 1461.087 -1607.098 -1227.816 -800.5095 nll$he(nll$par) ##           [,1]       [,2]       [,3]       [,4] ## [1,]  2302.540 -2926.1750 -1704.0103 -1226.3717 ## [2,] -2926.175  1672.1804  2316.4950   900.5366 ## [3,] -1704.010  2316.4950   948.3844  1516.5541 ## [4,] -1226.372   900.5366  1516.5541   273.1706"},{"path":"/articles/construct_nll.html","id":"extract-parameter-lowerupper-bounds","dir":"Articles","previous_headings":"","what":"Extract parameter lower/upper bounds","title":"construct_nll: How to extract function handlers, and choosing your own optimizer","text":"can extract parameter bounds specified calling add_parameters() method using get_parameters method (note nll$par pars$initial identical).","code":"pars = obj$get_parameters() print(pars) ##            type  estimate   initial     lower     upper ## logtheta   free  2.681123  1.609438      -Inf  2.995732 ## mu         free  1.076668  0.000000 -10.00000 10.000000 ## logsigma_x free  0.121665 -2.302585 -11.51293  1.609438 ## logsigma_y free -2.316746 -2.302585 -11.51293  1.609438"},{"path":"/articles/construct_nll.html","id":"optimize-manually-using-statsoptim","dir":"Articles","previous_headings":"","what":"Optimize manually using stats::optim","title":"construct_nll: How to extract function handlers, and choosing your own optimizer","text":"supply initial parameter values, objective function handler gradient handler, parameter bounds optim.","code":"opt = stats::optim(par=nll$par,                     fn=nll$fn,                     gr=nll$gr,                     method=\"L-BFGS-B\",                     lower=pars$lower,                     upper=pars$upper)"},{"path":"/articles/construct_nll.html","id":"compare-results-between-the-two-optimizers","dir":"Articles","previous_headings":"","what":"Compare results between the two optimizers","title":"construct_nll: How to extract function handlers, and choosing your own optimizer","text":"Lets compare results using stats::optim extracted function handler versus internal optimisation uses stats::nlminb stored fit:","code":"# Estimated parameters data.frame(external=opt$par, internal=fit$par.fixed) ##              external  internal ## logtheta    2.6811262  2.681123 ## mu          1.0766687  1.076668 ## logsigma_x  0.1216651  0.121665 ## logsigma_y -2.3167457 -2.316746 # Neg. Log-Likelihood data.frame(external=opt$value, internal=fit$nll) ##    external  internal ## 1 -38.68016 -38.68016 # Gradient components data.frame(external=t(nll$gr(opt$par)), internal=t(nll$gr(fit$par.fixed))) ##        external      internal ## 1  7.546370e-05 -2.483312e-07 ## 2 -2.566619e-05 -2.374608e-06 ## 3 -2.693510e-05  9.021387e-07 ## 4  2.748566e-06 -3.091434e-06"},{"path":"/articles/ctsmrTMB.html","id":"initialising","dir":"Articles","previous_headings":"","what":"Initialising","title":"Getting started","text":"initialise ctsmrTMB model object using can print object see kind model contains see model called sde_model (default), states, diffusions, observations, inputs parameters currently registered. name used name C++ file created locally, later recognize compiled model object.","code":"library(ctsmrTMB) obj = ctsmrTMB$new() print(obj) ## Stochastic State Space Model:                       ## Name         sde_model ## States               0 ## Diffusions           0 ## Observations         0 ## Inputs               0 ## Parameters           0"},{"path":"/articles/ctsmrTMB.html","id":"add-system-equations","dir":"Articles","previous_headings":"","what":"Add system equations","title":"Getting started","text":"can begin adding desired stochastic differential equation object. note drift term ends *dt diffusions specified dw dw# # can sequence numbers.","code":"obj$add_systems(dX ~ theta * (mu - X) * dt + sigma_x * dw)"},{"path":"/articles/ctsmrTMB.html","id":"add-observation-equations","dir":"Articles","previous_headings":"","what":"Add observation equations","title":"Getting started","text":"must also add observation equation. observations associated Y data also named Y.","code":"obj$add_observations(Y ~ X)"},{"path":"/articles/ctsmrTMB.html","id":"add-observation-variances","dir":"Articles","previous_headings":"","what":"Add observation variances","title":"Getting started","text":"every observation variable must also specify variance normally distributed residuals observation equation variable name left-hand side formula must match name previously defined via add_observations, variance associated observation equation. Let’s inspect model object now specified one state \\(X\\) observation \\(Y\\). diffusions count number \\(\\mathrm{d}\\omega_{}\\) terms. single equation can multiple diffusion terms .e. sigma_1 * dw1 + sigma_2*dw2). also note inputs parameter specified yet.","code":"obj$add_observation_variances(Y ~ sigma_y^2*U) print(obj) ## Stochastic State Space Model:                       ## Name         sde_model ## States               1 ## Diffusions           1 ## Observations         1 ## Inputs               0 ## Parameters           0 ##  ## System Equations: ##  ##   dX ~ theta * (mu - X) * dt + sigma_x * dw  ##  ## Observation Equations: ##  ##   Y:  Y ~ X + e   e ~ N(0, sigma_y^2 * U)"},{"path":"/articles/ctsmrTMB.html","id":"add-inputs","dir":"Articles","previous_headings":"","what":"Add inputs","title":"Getting started","text":"tell model variable names inputs via input values provided data, name, similar observations.","code":"obj$add_inputs(U)"},{"path":"/articles/ctsmrTMB.html","id":"add-parameters","dir":"Articles","previous_headings":"","what":"Add parameters","title":"Getting started","text":"must also specify (fixed effects) parameters, together initial value lower/upper bound, optimization. can fix parameter value (parameter becomes constant) supplying just single value. usually difficult identify noise parameters \\(\\left(\\sigma_{X},\\sigma_{Y}\\right)\\) practice, lets assume want fix \\(\\sigma_{Y}\\). done via Let’s inspect model object , see inputs parameters (non-fixed fixed) registered.","code":"obj$add_parameters(   theta   = c(initial = 5,    lower = 0,    upper = 20),   mu      = c(initial = 0,    lower = -10,  upper = 10),   sigma_x = c(initial = 1e-1, lower = 1e-5, upper = 5),   sigma_y = c(initial = 1e-1, lower = 1e-5, upper = 5) ) obj$add_parameters(   sigma_y  = 1e-1 ) print(obj) ## Stochastic State Space Model:                       ## Name         sde_model ## States               1 ## Diffusions           1 ## Observations         1 ## Inputs               1 ## Parameters           4 ##  ## System Equations: ##  ##   dX ~ theta * (mu - X) * dt + sigma_x * dw  ##  ## Observation Equations: ##  ##   Y:  Y ~ X + e   e ~ N(0, sigma_y^2 * U)  ##  ##  ## Parameters: ##   theta, mu, sigma_x, sigma_y ##  ## Fixed Parameters: ##   sigma_y"},{"path":"/articles/ctsmrTMB.html","id":"set-initial-state-and-covariance","dir":"Articles","previous_headings":"","what":"Set initial state and covariance","title":"Getting started","text":"last thing can perform estimation set initial value state(s) associated (co)variance. two inputs adequate since assume normally distributed state. choice value reflect ones belief initial state, often ballpark figure. Note use diag construct 1x1 matrix covariance, required method.","code":"obj$set_initial_state(mean=3, cov=1e-1*diag(1))"},{"path":"/articles/ctsmrTMB.html","id":"fit-model-parameters-to-data","dir":"Articles","previous_headings":"","what":"Fit model parameters to data","title":"Getting started","text":"now ready perform state filtration parameter estimation. first construct fake data simulating paths Ornstein-Uhlenbeck process using Euler-Maruyama scheme. data must contain time column named t columns specified inputs observations. pass data estimate method. method build compile generated C++ function negative log-likelihood, check supplied data contains necessary variables, construct objective function (computational tree must build automatic differentiation) start optimization. output generated optimization objective (negativ log-likelihood) value parameter values current step. optimizer used package stats::nlminb. optimizer great robustness ability use objective function hessian unlike e.g. ‘stats::optim’","code":"# Choosing parameters set.seed(10) theta=10; mu=1; sigma_x=1; sigma_y=1e-1   # Creating simulation path dt.sim = 1e-3 t.sim = seq(0,1,by=dt.sim) dw = rnorm(length(t.sim)-1,sd=sqrt(dt.sim)) x = 3 for(i in 1:(length(t.sim)-1)) {   x[i+1] = x[i] + theta*(mu-x[i])*dt.sim + sigma_x*dw[i] }  # Extract observations from simulation and add noise dt.obs = 1e-2 t.obs = seq(0,1,by=dt.obs) y = x[t.sim %in% t.obs] + sigma_y * rnorm(length(t.obs))  # Create data.frame data = data.frame(   t = t.obs,   Y = y,   U = c(rep(c(1,2),times=round(length(y)/2)),1) ) fit = obj$estimate(data) ## Building model... ## Checking data... ## Constructing objective function... ## Minimizing the negative log-likelihood... ##   0:     808.48858:  5.00000  0.00000 0.100000 ##   1:    -29.291023:  4.97496 0.143550  1.08933 ##   2:    -34.404382:  4.90454 0.633660  1.01980 ##   3:    -35.555271:  5.35861 0.842231  1.00190 ##   4:    -36.171321:  6.02319  1.02196 0.993127 ##   5:    -36.551317:  6.63048  1.07433  1.00075 ##   6:    -37.741283:  8.55553  1.10724  1.04330 ##   7:    -38.729612:  11.3498  1.03656  1.12073 ##   8:    -38.831473:  12.2040  1.08084  1.13412 ##   9:    -38.847424:  12.4277  1.07592  1.13902 ##  10:    -38.872562:  12.7023  1.07170  1.14269 ##  11:    -38.936364:  13.1666  1.06573  1.14339 ##  12:    -39.080656:  13.8810  1.05994  1.13185 ##  13:    -39.348152:  14.7206  1.05991  1.09054 ##  14:    -39.659041:  14.9526  1.06873  1.01493 ##  15:    -39.823363:  14.0309  1.07117 0.956704 ##  16:    -39.845458:  13.5307  1.07526 0.955351 ##  17:    -39.845633:  13.5086  1.07406 0.957327 ##  18:    -39.845649:  13.5199  1.07456 0.957509 ##  19:    -39.845650:  13.5174  1.07449 0.957327 ##  20:    -39.845650:  13.5175  1.07449 0.957348 ##  21:    -39.845650:  13.5175  1.07449 0.957348 ##   Optimization finished!: ##             Elapsed time: 0.004 seconds. ##             The objetive value is: -3.984565e+01 ##             The maximum gradient component is: 2.7e-06 ##             The convergence message is: relative convergence (4) ##             Iterations: 21 ##             Evaluations: Fun: 24 Grad: 22 ##             See stats::nlminb for available tolerance/control arguments."},{"path":"/articles/ctsmrTMB.html","id":"important-note-for-model-changes","dir":"Articles","previous_headings":"","what":"Important Note for Model Changes","title":"Getting started","text":"change model later stage retain model name, need recompile C++ objective function. can like : receive error messages calling estimate regarding variables specified model, likely forgot recompile.","code":"obj$estimate(data, compile=TRUE)"},{"path":"/articles/ctsmrTMB.html","id":"parameter-estimates","dir":"Articles","previous_headings":"","what":"Parameter estimates","title":"Getting started","text":"Let’s inspect results estimation. can print fit object see standard coefficient matrix parameter estimates. can see parameter estimate associated standard error together t-test statistic P-value associated standard null-hypothesis \\[ H_{0}: p = 0 \\\\ H_{1}: p \\neq 0 \\] Note true parameter values set simulation step \\(\\theta = 10\\), \\(\\mu=1\\) \\(\\sigma_{X} = 1\\). parameter values, standard deviations covariance matrix can extracted via: estimated (fixed) parameters: standard deviations (fixed) parameters: covariance (fixed) parameters:","code":"print(fit) ## Coefficent Matrix  ##          Estimate Std. Error t value  Pr(>|t|)     ## theta   13.517509   2.892036  4.6740 9.240e-06 *** ## mu       1.074490   0.075342 14.2615 < 2.2e-16 *** ## sigma_x  0.957348   0.132810  7.2084 1.095e-10 *** ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 fit$par.fixed ##      theta         mu    sigma_x  ## 13.5175090  1.0744895  0.9573478 fit$sd.fixed ## [1] 2.89203626 0.07534199 0.13280975 fit$cov.fixed ##            [,1]         [,2]         [,3] ## [1,] 8.36387372 0.0633139416 0.0956736164 ## [2,] 0.06331394 0.0056764161 0.0006344912 ## [3,] 0.09567362 0.0006344912 0.0176384286"},{"path":"/articles/ctsmrTMB.html","id":"state-estimates","dir":"Articles","previous_headings":"","what":"State estimates","title":"Getting started","text":"can also plot prior posterior state estimates prior state estimate resulting estimate purely integrating mean covariance SDE system forward time, posterior state estimation obtained updating prior estimate information contained observation (using Bayes’ rule).","code":"library(ggplot2) library(patchwork) # ggplot2 theme mytheme =   theme_minimal() +    theme(     text             = element_text(\"Avenir Next Condensed\",size=15),     legend.text      = element_text(size=15),     axis.text        = element_text(size=15),     strip.text       = element_text(face=\"bold\",size=15),     panel.grid.major = element_blank(),     panel.grid.minor = element_blank(),     legend.box       = \"vertical\",     legend.position  = \"top\",     plot.title       = element_text(hjust=0.5)   ) t         = fit$states$mean$posterior$t xprior    = fit$states$mean$prior$X xpost     = fit$states$mean$posterior$X xpost_sd  = fit$states$sd$posterior$X  ggplot() +   geom_line(aes(x=t,y=xpost,color=\"State Estimates (Posterior)\"),lwd=1) +   geom_line(aes(x=t,y=xprior,color=\"State Estimates (Prior)\"),lwd=1) +   geom_ribbon(aes(x=t,ymin=xpost-2*xpost_sd,ymax=xpost+2*xpost_sd),fill=\"grey\",alpha=0.5) +   geom_point(aes(x=data$t,data$Y,color=\"Observations\")) +   guides(color=guide_legend(override.aes=list(shape=c(16,NA,NA),size=c(2,NA,NA),linetype=c(NA,1,1),lwd=c(NA,1,1)))) +   labs(x = \"Time\", y = \"\", color=\"\") +   mytheme"},{"path":"/articles/ctsmrTMB.html","id":"residual-analysis","dir":"Articles","previous_headings":"","what":"Residual analysis","title":"Getting started","text":"can display standard residual analysis observations calling plot fit object, invokes S3 plot.ctsmrTMB.fit method plot. includes quantile-quantile plot, histogram, auto-correlations cumulative periodogram. residuals (standard normalized) can extracted well, together standard deviation covariance matrix via fit$residuals","code":"plot(fit)"},{"path":"/articles/ctsmrTMB.html","id":"extra-adding-algebraic-equations","dir":"Articles","previous_headings":"","what":"Extra: Adding algebraic equations","title":"Getting started","text":"sake clarity can sometimes easier specify simple variables equations place (perhaps larger) expression. can redefine variable name providing algebraic relation. Let’s say wish consider positive values parameter \\(\\theta\\), appropriate estimate log-domain (since domain logarithm positive real axis). use \\(\\theta = \\exp\\left(\\log\\theta\\right)\\) introduce parameter logtheta replace theta. obviously just names, might well written exp(theta) directly specifying system equations, calling parameter logtheta reminds one really interested exponential parameter. specify algebraic relation like : parameter settings theta automatically transformed logtheta, must redefined:","code":"obj$add_algebraics(theta ~ exp(logtheta)) obj$add_parameters(logtheta = log(c(initial=5, lower=0, upper=20)))"},{"path":"/articles/estimate.html","id":"construct-model-object","dir":"Articles","previous_headings":"","what":"Construct model object","title":"estimate: Estimating model parameters and states","text":"now construct ctsmrTMB model object per usual","code":"# Create model object obj = ctsmrTMB$new()  # Set name of model (and the created .cpp file) obj$set_modelname(\"ornstein_uhlenbeck\")  # Add system equations obj$add_systems(   dx ~ theta * (mu-x) * dt + sigma_x*dw )  # Add observation equations obj$add_observations(   y ~ x )  # Set observation equation variances obj$add_observation_variances(   y ~ sigma_y^2 )  # Specify algebraic relations obj$add_algebraics(   theta ~ exp(logtheta),   sigma_x ~ exp(logsigma_x),   sigma_y ~ exp(logsigma_y) )  # Specify parameter initial values and lower/upper bounds in estimation obj$add_parameters(   logtheta   = log(c(initial = 5,    lower = 0,    upper = 20)),   mu         = c(    initial = 0,    lower = -10,  upper = 10),   logsigma_x = log(c(initial = 1e-1, lower = 1e-5, upper = 5)),   logsigma_y = log(c(initial = 1e-1, lower = 1e-5, upper = 5)) )  # Set initial state mean and covariance obj$set_initial_state(x[1], 1e-1*diag(1))"},{"path":"/articles/estimate.html","id":"using-estimate---default-settings","dir":"Articles","previous_headings":"","what":"Using estimate - default settings","title":"estimate: Estimating model parameters and states","text":"can run estimate directly default settings using default settings Let’s walk various arguments effect:","code":"obj$estimate(.data) obj$estimate(.data,              method=\"ekf\",              ode.solver=\"euler\",              ode.timestep=min(diff(.data$t)),              loss = \"quadratic\",              loss_c = 3,              use.hessian = FALSE,              compile=FALSE,              control=list(trace=1) )"},{"path":"/articles/estimate.html","id":"argument-method","dir":"Articles","previous_headings":"","what":"Argument: method","title":"estimate: Estimating model parameters and states","text":"method argument determines underlying estimation techniques used. current implementation supports following method='ekf': Extended Kalman Filter. method='ukf': Unscented Kalman Filter. method='tmb': Laplace Approximation former two quite similar based Kalman Filter theory. assumptions normality state transition observation equation fundamental, although implemented filters standard non-linear filters, sense try overcome assumptions small non-linearities. Unscented Kalman Filter generally considered perform better cases. latter tmb method aptly named TMB package employs Laplace Approximation method integration random effects. formulation consider states random effects, parameters fixed. underlying assumption one normality, implementation allows flexibility choosing arbitrary distributions (yet implemented.) methods can used estimate parameter states. case tmb states smoothed (conditioned past future observations).","code":""},{"path":"/articles/estimate.html","id":"argument-ode-solver","dir":"Articles","previous_headings":"","what":"Argument: ode.solver","title":"estimate: Estimating model parameters and states","text":"argument used Kalman Filter methods .e. ekf ukf. argument determines algorithm used integrate forward moment (mean variance) differential equations. current implementation supports ode.solver='euler': forward Euler scheme ode.solver='rk4': 4th order Runge-Kutta scheme","code":""},{"path":"/articles/estimate.html","id":"argument-ode-timestep","dir":"Articles","previous_headings":"","what":"Argument: ode.timestep","title":"estimate: Estimating model parameters and states","text":"argument determines time-step used ODE solvers","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"/articles/gettingStarted.html","id":"r-markdown","dir":"Articles","previous_headings":"","what":"R Markdown","title":"Getting Started","text":"R Markdown document. Markdown simple formatting syntax authoring HTML, PDF, MS Word documents. details using R Markdown see http://rmarkdown.rstudio.com. click Knit button document generated includes content well output embedded R code chunks within document. can embed R code chunk like :","code":"summary(cars) ##      speed           dist        ##  Min.   : 4.0   Min.   :  2.00   ##  1st Qu.:12.0   1st Qu.: 26.00   ##  Median :15.0   Median : 36.00   ##  Mean   :15.4   Mean   : 42.98   ##  3rd Qu.:19.0   3rd Qu.: 56.00   ##  Max.   :25.0   Max.   :120.00"},{"path":"/articles/gettingStarted.html","id":"including-plots","dir":"Articles","previous_headings":"","what":"Including Plots","title":"Getting Started","text":"can also embed plots, example:  Note echo = FALSE parameter added code chunk prevent printing R code generated plot.","code":""},{"path":"/articles/observation_equations.html","id":"adding-observation-equations","dir":"Articles","previous_headings":"","what":"Adding observation equations","title":"observations: Using functions on the left-hand side","text":"Let’s assume observations \\(y_{t}\\) log-normally distributed conditioned \\(x_{t}\\) .e. \\[ \\log y_{t_{}} \\sim \\mathcal{N}(x_{t_{}},\\sigma_{y}^{2}) \\] sufficient user provide data column y provided data.frame e.g. estimate predict adding following observation equation Note kind observation equations, left-hand side function one () observed variables must explicitly named using obsnames argument.","code":"obj$add_observations(   log(y) ~ x, obsnames = \"log_y\" )"},{"path":"/articles/observation_equations.html","id":"adding-observation-variances","dir":"Articles","previous_headings":"","what":"Adding observation variances","title":"observations: Using functions on the left-hand side","text":"names given obsnames important needed specify observation variance. example code work, observation named log_y correct way add observation variance :","code":"obj$add_observation_variances(   y ~ sigma_y^2 ) ## Error in check_observation_variance_eqs(form, self, private): Please add an observation equation for y before specifying its variance obj$add_observation_variances(   log_y ~ sigma_y^2 )"},{"path":"/articles/observation_equations.html","id":"multiple-observation-equations","dir":"Articles","previous_headings":"","what":"Multiple observation equations","title":"observations: Using functions on the left-hand side","text":"must supply multiple obsnames supplying multiple observatin equations, although name used left-hand side just single variable .e.","code":"obj$add_observations(   log(y) ~ x,   y ~ x,   y^2+z^3 ~ x,   obsnames = c(\"log_y\", NA, \"y2_plus_z3\") )"},{"path":"/articles/predict.html","id":"simulate-from-the-ornstein-uhlenbeck-process","dir":"Articles","previous_headings":"","what":"Simulate from the Ornstein-Uhlenbeck process","title":"predict: Forecasting the model states and observations.","text":"use Ornstein-Uhlenbeck process . \\[ \\mathrm{d}X_{t} = \\theta (\\mu - X_{t}) \\, \\mathrm{d}t \\, + \\sigma_{X} \\, \\mathrm{d}B_{t} \\] \\[ Y_{t_{k}} = X_{t_{k}} + e_{t_{k}}, \\qquad e_{t_{k}} \\sim \\mathcal{N}\\left(0,\\sigma_{Y}^{2}\\right)   \\] first create data simulating process","code":"# Simulate data using Euler Maruyama set.seed(10) theta=10; mu=1; sigma_x=1; sigma_y=1e-1 #  dt.sim = 1e-3 t.sim = seq(0,1,by=dt.sim) dw = rnorm(length(t.sim)-1,sd=sqrt(dt.sim)) x = 3 for(i in 1:(length(t.sim)-1)) {   x[i+1] = x[i] + theta*(mu-x[i])*dt.sim + sigma_x*dw[i] }  # Extract observations and add noise dt.obs = 1e-2 t.obs = seq(0,1,by=dt.obs) y = x[t.sim %in% t.obs] + sigma_y * rnorm(length(t.obs))  # Create data .data = data.frame(   t = t.obs,   y = y )"},{"path":"/articles/predict.html","id":"construct-model-object","dir":"Articles","previous_headings":"","what":"Construct model object","title":"predict: Forecasting the model states and observations.","text":"now construct ctsmrTMB model object","code":"# Create model object obj = ctsmrTMB$new()  # Set name of model (and the created .cpp file) obj$set_modelname(\"ornstein_uhlenbeck\")  # Add system equations obj$add_systems(   dx ~ theta * (mu-x) * dt + sigma_x*dw )  # Add observation equations obj$add_observations(   y ~ x )  # Set observation equation variances obj$add_observation_variances(   y ~ sigma_y^2 )  # Specify algebraic relations obj$add_algebraics(   theta ~ exp(logtheta),   sigma_x ~ exp(logsigma_x),   sigma_y ~ exp(logsigma_y) )  # Specify parameter initial values and lower/upper bounds in estimation obj$add_parameters(   logtheta   = log(c(initial = 5,    lower = 0,    upper = 20)),   mu         = c(    initial = 0,    lower = -10,  upper = 10),   logsigma_x = log(c(initial = 1e-1, lower = 1e-5, upper = 5)),   logsigma_y = log(c(initial = 1e-1, lower = 1e-5, upper = 5)) )  # Set initial state mean and covariance obj$set_initial_state(x[1], 1e-1*diag(1))"},{"path":"/articles/predict.html","id":"predict","dir":"Articles","previous_headings":"","what":"Predict","title":"predict: Forecasting the model states and observations.","text":"can use predict function without called estimate first, case initial value parameters provided add_parameters used. output predict data.frame indices time-points, state values associated standard deviations, observations provided data, predicted observation values based predicted state values. indices j table refer expectation variance state vector \\[ \\mathrm{E}(x_{t_{}} | x_{t_{j}}, y_{t_{j}}) \\\\ \\mathrm{V}(x_{t_{}} | x_{t_{j}}, y_{t_{j}}) \\] moments given indices \\(\\) (time \\(t_{}\\)) conditioned information available indices \\(j\\) (time \\(t_{j}\\)). sense state/covariance predictions \\(=j\\) posterior estimates, others prior estimates. default standard deviations states returned. entire covariance matrix elements can returned via","code":"pred = obj$predict(.data) head(pred) ##   i. j.  t.i  t.j k.ahead        x       var.x        y   y.data ## 1  0  0 0.00 0.00       0 3.000000 0.100000000 3.000000 3.105001 ## 2  0  1 0.00 0.01       1 2.850000 0.090100000 2.850000 2.687603 ## 3  1  1 0.01 0.01       0 2.703827 0.009000999 2.703827 2.687603 ## 4  1  2 0.01 0.02       1 2.568636 0.008200899 2.568636 2.634588 ## 5  2  2 0.02 0.02       0 2.598352 0.004505766 2.598352 2.634588 ## 6  2  3 0.02 0.03       1 2.468434 0.004155189 2.468434 2.267096 obj$predict(.data, return.covariance = TRUE)"},{"path":"/articles/predict.html","id":"set-number-of-prediction-steps","dir":"Articles","previous_headings":"","what":"Set number of prediction steps","title":"predict: Forecasting the model states and observations.","text":"number time steps ahead predictions desired can changed k.ahead argument. default behaviour save prediction steps 1 k.ahead selected desired, return.k.ahead argument can used indicate kept output.","code":"pred1 = obj$predict(.data, k.ahead=2) pred2 = obj$predict(.data, k.ahead=10, return.k.ahead=c(2,5,8)) head(pred1) ##   i. j.  t.i  t.j k.ahead        x       var.x        y   y.data ## 1  0  0 0.00 0.00       0 3.000000 0.100000000 3.000000 3.105001 ## 2  0  1 0.00 0.01       1 2.850000 0.090100000 2.850000 2.687603 ## 3  0  2 0.00 0.02       2 2.707500 0.081190000 2.707500 2.634588 ## 4  1  1 0.01 0.01       0 2.703827 0.009000999 2.703827 2.687603 ## 5  1  2 0.01 0.02       1 2.568636 0.008200899 2.568636 2.634588 ## 6  1  3 0.01 0.03       2 2.440204 0.007480809 2.440204 2.267096 head(pred2) ##    i. j.  t.i  t.j k.ahead        x       var.x        y   y.data ## 3   0  2 0.00 0.02       2 2.707500 0.081190000 2.707500 2.634588 ## 6   0  5 0.00 0.05       5 2.321343 0.059458510 2.321343 1.810241 ## 9   0  8 0.00 0.08       8 1.990261 0.043616254 1.990261 1.409952 ## 14  1  3 0.01 0.03       2 2.440204 0.007480809 2.440204 2.267096 ## 17  1  6 0.01 0.06       5 2.092170 0.005724510 2.092170 1.772193 ## 20  1  9 0.01 0.09       8 1.793774 0.004444168 1.793774 1.706040"},{"path":"/articles/predict.html","id":"set-the-model-parameters-used","dir":"Articles","previous_headings":"","what":"Set the model parameters used","title":"predict: Forecasting the model states and observations.","text":"default predict use initial parameters supplied add_parameters, unless estimate function succesfully run, predict use parameter values found minimizer. can provide parameters using pars argument method .e.","code":"some.other.random.pars = rnorm(length(fit$par.fixed)) pred = obj$predict(.data, pars=some.other.random.pars)"},{"path":"/articles/predict.html","id":"set-the-initial-state-and-covariance","dir":"Articles","previous_headings":"","what":"Set the initial state and covariance","title":"predict: Forecasting the model states and observations.","text":"default behaviour predict use initial state covariance suppled calling set_initial_state method. can important change one wishes correctly predict first observations provided prediction data series. can supply x0 p0 arguments updated state covariance estimates","code":"new.initial.x0 = rnorm(1) new.initial.p0 = rnorm(1)*diag(1) pred = obj$predict(.data,             x0=new.state.value,             p0=new.covariance.value)"},{"path":"/articles/predict.html","id":"the-solver-options","dir":"Articles","previous_headings":"","what":"The solver options","title":"predict: Forecasting the model states and observations.","text":"can choose solver options use via arguments ode.solver ode.timestep. ode.solver decides ode solver algorithm used solving mean variance ODEs SDE. ode.timestep determines time step-size using solving ODEs, default value minimum observed time difference provided data time vector (min(diff(.data$t))). time step-size can’t smaller . chosen time step-size \\(\\Delta_{step}\\) “almost” divide observation time differences data \\(\\Delta_{obs}\\) .e. \\[ \\frac{\\Delta_{obs}}{\\Delta_{step}} - \\bigg\\lfloor \\frac{\\Delta_{obs}}{\\Delta_{step}} \\bigg\\rfloor \\geq 0.02 \\] time step-size reduced divide evenly setting \\[ \\frac{\\Delta_{obs}}{\\Delta_{step}} = \\bigg\\lceil \\frac{\\Delta_{obs}}{\\Delta_{step}} \\bigg\\rceil \\] words: takes \\(3.561\\) time-steps get \\(t_{}\\) \\(t_{+1}\\) take \\(4\\) time-steps instead, calculate reduced time-step true. \\(3.01\\) time-steps retain original time-step, ignoring small temporal discrepancy. provide arguments via","code":"obj$predict(.data,             ode.solver = \"euler\",             ode.timestep = min(diff(.data$t)) )"},{"path":"/articles/predict.html","id":"use-case","dir":"Articles","previous_headings":"","what":"Use-case","title":"predict: Forecasting the model states and observations.","text":"use model predictions observation compute model performance score e.g. RMSE (root-mean square error). first estimate model parameters, automatically used calling predict. predict 10-steps ahead, return values. Let’s plot 10-step predictions observations. notice 10-step predictions state uncertainty (95%) much larger filtered posterior state estimates fit .e. can calculate RMSE prediction score prediction step follows:","code":"fit = obj$estimate(.data) pred = obj$predict(.data, k.ahead=10) # ggplot2 theme library(ggplot2) mytheme =   theme_minimal() +    theme(     text             = element_text(\"Avenir Next Condensed\",size=15),     legend.text      = element_text(size=15),     axis.text        = element_text(size=15),     strip.text       = element_text(face=\"bold\",size=15),     panel.grid.major = element_blank(),     panel.grid.minor = element_blank(),     legend.box       = \"vertical\",     legend.position  = \"top\",     plot.title       = element_text(hjust=0.5)   ) pred10 = pred[pred$k.ahead==10,] data = .data ggplot() +   geom_line(aes(x=pred10$t.j,y=pred10$x,color=\"10-Step Predictions\")) +     geom_ribbon(aes(x=pred10$t.j,ymin=pred10$x-2*sqrt(pred10$var.x),ymax=pred10$x+2*sqrt(pred10$var.x)),fill=\"grey\",alpha=0.5) +   geom_point(aes(x=data$t,data$y,color=\"Observations\")) +   labs(color=\"\",x=\"Time\",y=\"\") +   # coord_cartesian(xlim=c(0,0.1)) +   mytheme t         = fit$states$mean$posterior$t xpost     = fit$states$mean$posterior$x xpost_sd  = fit$states$sd$posterior$x  ggplot() +   geom_line(aes(x=t,y=xpost,color=\"0-Step Predictions (Posterior State Estimates)\"),lwd=1) +   geom_ribbon(aes(x=t,ymin=xpost-2*xpost_sd,ymax=xpost+2*xpost_sd),fill=\"grey\",alpha=0.5) +   geom_point(aes(x=data$t,data$y,color=\"Observations\")) +   labs(x = \"Time\", y = \"\", color=\"\") +   mytheme RMSE = c() for(i in 1:10){   x_y = pred[pred$k.ahead==i,][c(\"x\",\"y\")]   RMSE[i] = sqrt(mean((x_y[[\"x\"]] - x_y[[\"y\"]])^2)) }  ggplot(data=data.frame(x=1:10,y=RMSE),aes(x,y,color=\"RMSE\")) +   geom_line() + geom_point() +   labs(color=\"\") +   mytheme"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Phillip Vetter. Author, maintainer. Jan Møller. Contributor. Uffe Thygesen. Contributor. Peder Bacher. Contributor. Henrik Madsen. Contributor.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Vetter P (2023). ctsmrTMB: Continuous Time Stochastic Modelling Template Model Builder. https://phillipbvetter.github.io/ctsmrTMB, https://github.com/phillipbvetter/ctsmrTMB.","code":"@Manual{,   title = {ctsmrTMB: Continuous Time Stochastic Modelling with Template Model Builder},   author = {Phillip Vetter},   year = {2023},   note = {https://phillipbvetter.github.io/ctsmrTMB, https://github.com/phillipbvetter/ctsmrTMB}, }"},{"path":"/index.html","id":"continous-time-stochastic-modelling-in-r-using-template-model-builder","dir":"","previous_headings":"","what":"Continous Time Stochastic Modelling in R using Template Model Builder","title":"Continuous Time Stochastic Modelling with Template Model Builder","text":"Welcome homepage ctsmrTMB. ctsmrTMB R package parameter estimation, state filtration forecasting stochastic state space system. package maintained group researchers Technical University Denmark (DTU), Department Applied Mathematics Computer Science, section Dynamical Systems. package successor ctsmr package whose FORTRAN libraries became increasingly difficult maintain section. now instead rely TMB package gives easy access series fast modern C++ libraries, including automatic differentiation CppAD. package implements R6 class object user specifies state space model consists system stochastic differential equations (SDEs) series algebraic observation equations (AOEs). package uses defined model system user-supplied dataset observations write C++ function form accepted TMB calculates negative log-likelihood.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Continuous Time Stochastic Modelling with Template Model Builder","text":"can install latest version using also follow installation instructions TMB get everything working. Windows users must Rtools intalled, Mac users must Command Line Tools various compilers. can read TMB GitHub .","code":"remotes::install_github(repo=\"phillipbvetter/ctsmrTMB\", dependencies=TRUE)"},{"path":"/index.html","id":"getting-started","dir":"","previous_headings":"","what":"Getting Started","title":"Continuous Time Stochastic Modelling with Template Model Builder","text":"new user recommend check Getting Started vignette start learning simple steps using ctsmrTMB. can find documentation methods .","code":""},{"path":"/index.html","id":"example-usage","dir":"","previous_headings":"","what":"Example Usage","title":"Continuous Time Stochastic Modelling with Template Model Builder","text":"","code":"library(ctsmrTMB) library(ggplot2) library(patchwork)  ############################################################ # Data simulation ############################################################  # Simulate data using Euler Maruyama set.seed(10) pars = c(theta=10, mu=1, sigma_x=1, sigma_y=1e-2) #  dt.sim = 1e-3 t.sim = seq(0,1,by=dt.sim) dw = rnorm(length(t.sim)-1,sd=sqrt(dt.sim)) x = 3 for(i in 1:(length(t.sim)-1)) {   x[i+1] = x[i] + pars[1]*(pars[2]-x[i])*dt.sim + pars[3]*dw[i] }  # Extract observations and add noise dt.obs = 1e-2 t.obs = seq(0,1,by=dt.obs) y = x[t.sim %in% t.obs] + pars[4] * rnorm(length(t.obs))  # Create data .data = data.frame(   t = t.obs,   y = y )  ############################################################ # Model creation and estimation ############################################################  # Create model object obj = ctsmrTMB$new()  # Set name of model (and the created .cpp file) obj$set_modelname(\"ornstein_uhlenbeck\")  # Set path where generated C++ files are saved. # This will create a cppfiles folder in your current working directory if it doesnt exist obj$set_cppfile_directory(\"cppfiles\")  # Add system equations obj$add_systems(   dx ~ theta * (mu-x) * dt + sigma_x*dw )  # Add observation equations obj$add_observations(   y ~ x )  # Set observation equation variances obj$add_observation_variances(   y ~ sigma_y^2 )  # Specify algebraic relations obj$add_algebraics(   theta   ~ exp(logtheta),   sigma_x ~ exp(logsigma_x),   sigma_y ~ exp(logsigma_y) )  # Specify parameter initial values and lower/upper bounds in estimation obj$add_parameters(   logtheta    = log(c(init = 1, lower=1e-5, upper=50)),   mu          = c(init=1.5, lower=0, upper=5),   logsigma_x  = log(c(init= 1e-1, lower=1e-10, upper=10)),   logsigma_y  = log(c(init=1e-1, lower=1e-10, upper=10)) )  # Set initial state mean and covariance obj$set_initial_state(x[1], 1e-1*diag(1))  # Carry out estimation using extended kalman filter method with stats::nlminb as optimizer fit <- obj$estimate(data=.data, method=\"ekf\", ode.solver=\"rk4\", use.hessian=TRUE)  # Check parameter estimates against truth x = fit$par.fixed cbind(c(exp(x[1]),x[2],exp(x[3]),exp(x[4])), pars)  # plot one-step predictions, simulated states and observations t.est = fit$states$mean$prior$t x.mean = fit$states$mean$prior$x x.sd = fit$states$sd$prior$x ggplot() +   geom_ribbon(aes(x=t.est, ymin=x.mean-2*x.sd, ymax=x.mean+2*x.sd),fill=\"grey\", alpha=0.9) +   geom_line(aes(x=t.est, x.mean),col=\"steelblue\",lwd=1) +   geom_line(aes(x=t.sim,y=x)) +    geom_point(aes(x=t.obs,y=y),col=\"tomato\",size=2) +   theme_minimal()   # Plot one-step-ahead residual analysis plot(fit, use.ggplot=T)  # Predict to obtain k-step-ahead predictions to see model forecasting ability pred = obj$predict(data=.data, k.ahead=10, method=\"ekf\", ode.solver=\"rk4\")  # Plot all 10-step predictions against data pred10step = pred[pred$k.ahead==10,] ggplot() +   geom_point(aes(x=t.obs,y=y),color=\"steelblue\") +   geom_point(aes(x=pred10step$t.j,pred10step$x),color=\"tomato\") +   geom_errorbar(aes(x=pred10step$t.j,                      ymin=pred10step$x-2*sqrt(pred10step$var.x),                      ymax=pred10step$x+2*sqrt(pred10step$var.x)),color=\"tomato\") +   theme_minimal()"},{"path":"/reference/ctsmrTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Constructor for R6 ctsmrTMB class — ctsmrTMB","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"Call ctsmrTMB$new() construct new instance class object specifying new stochastic state space model.","code":""},{"path":"/reference/ctsmrTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"model object class 'ctsmrTMB'","code":""},{"path":[]},{"path":"/reference/ctsmrTMB.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"ctsmrTMB$new() ctsmrTMB$add_systems() ctsmrTMB$add_observations() ctsmrTMB$add_observation_variances() ctsmrTMB$add_inputs() ctsmrTMB$add_parameters() ctsmrTMB$add_algebraics() ctsmrTMB$add_constants() ctsmrTMB$set_initial_state() ctsmrTMB$set_lamperti() ctsmrTMB$set_modelname() ctsmrTMB$set_cppfile_directory() ctsmrTMB$set_map() ctsmrTMB$get_systems() ctsmrTMB$get_observations() ctsmrTMB$get_observation_variances() ctsmrTMB$get_algebraics() ctsmrTMB$get_parameters() ctsmrTMB$construct_nll() ctsmrTMB$estimate() ctsmrTMB$predict() ctsmrTMB$print() ctsmrTMB$summary() ctsmrTMB$plot() ctsmrTMB$clone()","code":""},{"path":"/reference/ctsmrTMB.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"Construct new ctsmrTMB model object.","code":""},{"path":"/reference/ctsmrTMB.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"","code":"ctsmrTMB$new()"},{"path":"/reference/ctsmrTMB.html","id":"method-add-systems-","dir":"Reference","previous_headings":"","what":"Method add_systems()","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"Define add multiple stochastic differential equation governing process individual state variables form d<state> ~ f(t,<states>,<inputs>) * dt + g1(t,<states>,<inputs>) * dw1                                           + g2(t,<states>,<inputs>) * dw2                                             + ... f drift, g1, g2, ... diffusions, differential brownian motions dw1, dw2, ...","code":""},{"path":"/reference/ctsmrTMB.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"","code":"ctsmrTMB$add_systems(form, ...)"},{"path":"/reference/ctsmrTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"form formula specifying stochastic differential equation added system. ... additional formulas similar form specifying multiple equations .","code":""},{"path":"/reference/ctsmrTMB.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"","code":"# Specify Ornstein-Uhlenbeck Process add_systems(dX ~ theta * (mu - X + u) * dt + sigma * dw)  # Specify Lokta-Volterra System of Equations add_systems( dN ~ ( r * N * (1-N/K) - c*N*P/(N+Nbar) ) * dt + sigmaN * N * dw1,              dP ~ ( eps*c*N*P/(N+Nbar) - mu * P ) * dt + sigmaP * P * dw2 )"},{"path":"/reference/ctsmrTMB.html","id":"method-add-observations-","dir":"Reference","previous_headings":"","what":"Method add_observations()","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"Define add relationship observed variable system states. observation equation takes form <observation> ~ h(t,<states>,<inputs>) + e) h observation function, e normally distributed noise zero mean variance specified. observation variable present data provided calling estimate(.data) parameter estimation.","code":""},{"path":"/reference/ctsmrTMB.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"","code":"ctsmrTMB$add_observations(form, ..., obsnames = NULL)"},{"path":"/reference/ctsmrTMB.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"form formula class specifying obsevation equation added system. ... additional formulas identical form specify multiple observation equations time. obsnames character vector specifying name observation. observation left-hand side consists just single variable name (class 'call' instead 'name') given name form obs__# # number, unless obsnames provided.","code":""},{"path":"/reference/ctsmrTMB.html","id":"examples-1","dir":"Reference","previous_headings":"","what":"Examples","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"","code":"#Specify observation directly as a latent state add_observations(y ~ x)  Specify observation as the sum of exponentials of two latent states add_observations(y ~ exp(x1) + exp(x2))"},{"path":"/reference/ctsmrTMB.html","id":"method-add-observation-variances-","dir":"Reference","previous_headings":"","what":"Method add_observation_variances()","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"Specify variance observation equation. defined observation variable y e.g. add_observations(y ~  h(t,<states>,<inputs>) pertubed Gaussian noise zero mean variance -specified using add_observation_variances(y ~ p(t,<states>,<inputs>). can instance declare add_observation_variances(y ~ sigma_x^2 sigma_x fixed effect parameter declared add_parameters.","code":""},{"path":"/reference/ctsmrTMB.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"","code":"ctsmrTMB$add_observation_variances(form, ...)"},{"path":"/reference/ctsmrTMB.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"form formula class specifying obsevation equation added system. ... additional formulas identical form specify multiple observation equations time.","code":""},{"path":"/reference/ctsmrTMB.html","id":"method-add-inputs-","dir":"Reference","previous_headings":"","what":"Method add_inputs()","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"Declare variables data inputs Declare whether variable contained system, observation observation variance equations input variable. e.g. system equation contains input variable u declared using add_inputs(u). input u must contained data.frame .data provided calling estimate predict methods.","code":""},{"path":"/reference/ctsmrTMB.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"","code":"ctsmrTMB$add_inputs(...)"},{"path":"/reference/ctsmrTMB.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"... unquoted variable names specifies name input variables defined system.","code":""},{"path":"/reference/ctsmrTMB.html","id":"method-add-parameters-","dir":"Reference","previous_headings":"","what":"Method add_parameters()","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"Declare variables fixed effects specify initial value, lower upper bound used calling maximum likelihood optimization. two ways declare parameters. can declare parameters using formulas .e. add_parameters( theta = c(1,0,10), mu = c(0,-10,10) ), values initial, lower upper bound respectively. Alternatively can provide 3-column matrix rows corresponds different parameters, parameter names provided rownames matrix.","code":""},{"path":"/reference/ctsmrTMB.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"","code":"ctsmrTMB$add_parameters(...)"},{"path":"/reference/ctsmrTMB.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"... formula whose left-hand side parameter name, right hand side vector length 3 inital value, lower upper bound respectively. can provide multiple parameters seperating formulas comma. parameter.matrix matrix 3 columns rows correspond variables. variable names must provided rownames matrix. columns initial value, lower upper bound respectively.","code":""},{"path":"/reference/ctsmrTMB.html","id":"method-add-algebraics-","dir":"Reference","previous_headings":"","what":"Method add_algebraics()","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"Add algebraic relations. Algebraic relations convenient way transform parameters equations. Ornstein-Uhlenbeck process rate parameter theta always positive, estimation log-domain good idea. Instead writing exp(theta) directly system equation one can transform log domain using algebraic relation add_algebraics(theta ~ exp(logtheta)). instances theta replaced exp(logtheta) compiling C++ function. Note must provide values logtheta now instead theta declaring parameters add_parameters","code":""},{"path":"/reference/ctsmrTMB.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"","code":"ctsmrTMB$add_algebraics(form, ...)"},{"path":"/reference/ctsmrTMB.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"form formula specifying stochastic differential equation(s) added system. ... additional formulas similar form specifying multiple equations .","code":""},{"path":"/reference/ctsmrTMB.html","id":"method-add-constants-","dir":"Reference","previous_headings":"","what":"Method add_constants()","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"Declare variables scalar constants.","code":""},{"path":"/reference/ctsmrTMB.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"","code":"ctsmrTMB$add_constants(...)"},{"path":"/reference/ctsmrTMB.html","id":"arguments-6","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"... additional formulas similar form specifying multiple constants . form formula whose left-hand side constant variable name, right-hand side numeric value.","code":""},{"path":"/reference/ctsmrTMB.html","id":"method-set-initial-state-","dir":"Reference","previous_headings":"","what":"Method set_initial_state()","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"Declare initial state values .e. mean covariance system states.","code":""},{"path":"/reference/ctsmrTMB.html","id":"usage-8","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"","code":"ctsmrTMB$set_initial_state(mean, cov, estimate = FALSE)"},{"path":"/reference/ctsmrTMB.html","id":"arguments-7","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"mean numeric vector size equal n (number system states) cov matrix (symmetric positive semi-definite) dimensions n^2. estimate boolean value indicates whether initial conditions shall estimated fixed effects parameters. provided mean covariance used initial guesses","code":""},{"path":"/reference/ctsmrTMB.html","id":"method-set-lamperti-","dir":"Reference","previous_headings":"","what":"Method set_lamperti()","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"Set Lamperti Transformation provided system equations state dependent diffusion available ways advantageous perform transformation remove state dependence. comes cost complicated drift function. following types state-dependence currently supported transformation desired choose 'identity' (default). diffusion term proportional x * dw, log-transform available diffusion term proportional x * (1-x) * dw, logit-transform available diffusion term proportional sqrt(x * (1-x)) * dw, sqrt-logit-transform available diffusion term proportional x * (1-x^) * dw, >0 power-logit transform available","code":""},{"path":"/reference/ctsmrTMB.html","id":"usage-9","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"","code":"ctsmrTMB$set_lamperti(transform, states = NULL)"},{"path":"/reference/ctsmrTMB.html","id":"arguments-8","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"transform character vector - one either \"identity, \"log\", \"logit\", \"sqrt-logit\", \"power-logit\" states vector state names chosen transformation desired. default (NULL) apply transformation state equations.","code":""},{"path":"/reference/ctsmrTMB.html","id":"method-set-modelname-","dir":"Reference","previous_headings":"","what":"Method set_modelname()","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"Set modelname used create C++ file TMB calling TMB::MakeADFun (negative log) likelihood function created directory specified set_cppfile_directory method name <modelname>.cpp","code":""},{"path":"/reference/ctsmrTMB.html","id":"usage-10","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"","code":"ctsmrTMB$set_modelname(name)"},{"path":"/reference/ctsmrTMB.html","id":"arguments-9","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"name string defining model name.","code":""},{"path":"/reference/ctsmrTMB.html","id":"method-set-cppfile-directory-","dir":"Reference","previous_headings":"","what":"Method set_cppfile_directory()","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"Set path directory constructed C++ file created. specify entire path, unless want construct subfolder current working directory - can call e.g. set_cppfile_directory(\"folder_in_current_wd\").","code":""},{"path":"/reference/ctsmrTMB.html","id":"usage-11","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"","code":"ctsmrTMB$set_cppfile_directory(directory)"},{"path":"/reference/ctsmrTMB.html","id":"arguments-10","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"directory string specifying local directory","code":""},{"path":"/reference/ctsmrTMB.html","id":"method-set-map-","dir":"Reference","previous_headings":"","what":"Method set_map()","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"Enable maximum posterior (MAP) estimation. Adds maximum posterior contribution (negative log) likelihood function evaluating fixed effects parameters multivariate Gaussian mean covariance provided.","code":""},{"path":"/reference/ctsmrTMB.html","id":"usage-12","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"","code":"ctsmrTMB$set_map(mean, cov)"},{"path":"/reference/ctsmrTMB.html","id":"arguments-11","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"mean mean vector Gaussian prior parameter distribution cov covariance matrix Gaussian prior parameter distribution","code":""},{"path":"/reference/ctsmrTMB.html","id":"method-get-systems-","dir":"Reference","previous_headings":"","what":"Method get_systems()","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"Retrieve system equations.","code":""},{"path":"/reference/ctsmrTMB.html","id":"usage-13","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"","code":"ctsmrTMB$get_systems()"},{"path":"/reference/ctsmrTMB.html","id":"method-get-observations-","dir":"Reference","previous_headings":"","what":"Method get_observations()","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"Retrieve observation equations.","code":""},{"path":"/reference/ctsmrTMB.html","id":"usage-14","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"","code":"ctsmrTMB$get_observations()"},{"path":"/reference/ctsmrTMB.html","id":"method-get-observation-variances-","dir":"Reference","previous_headings":"","what":"Method get_observation_variances()","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"Retrieve observation variances","code":""},{"path":"/reference/ctsmrTMB.html","id":"usage-15","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"","code":"ctsmrTMB$get_observation_variances()"},{"path":"/reference/ctsmrTMB.html","id":"method-get-algebraics-","dir":"Reference","previous_headings":"","what":"Method get_algebraics()","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"Retrieve algebraic relations","code":""},{"path":"/reference/ctsmrTMB.html","id":"usage-16","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"","code":"ctsmrTMB$get_algebraics()"},{"path":"/reference/ctsmrTMB.html","id":"method-get-parameters-","dir":"Reference","previous_headings":"","what":"Method get_parameters()","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"Get initial (estimated) parameters.","code":""},{"path":"/reference/ctsmrTMB.html","id":"usage-17","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"","code":"ctsmrTMB$get_parameters()"},{"path":"/reference/ctsmrTMB.html","id":"method-construct-nll-","dir":"Reference","previous_headings":"","what":"Method construct_nll()","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"Construct extract function handlers negative log likelihood function. handlers TMB's MakeADFun constructed returned. enables user e.g. determine optimization algorithm use estimation.","code":""},{"path":"/reference/ctsmrTMB.html","id":"usage-18","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"","code":"ctsmrTMB$construct_nll(   data,   method = \"ekf\",   ode.solver = \"euler\",   ode.timestep = min(diff(data$t)),   loss = \"quadratic\",   loss_c = 3,   compile = FALSE,   silent = FALSE )"},{"path":"/reference/ctsmrTMB.html","id":"arguments-12","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"data data.frame containing time-vector 't', observations inputs. observations can take NA-values. method character vector - one either \"ekf\", \"ukf\" \"tmb\". Sets estimation method. package three available methods implemented: natural TMB-style formulation latent states considered random effects integrated using Laplace approximation. method yields gradient (negative log) likelihood function respect fixed effects optimization. method slower although probably precision advantages, allows non-Gaussian observation noise (yet implemented). One-step / K-step residuals yet available package. (Continous-Discrete) Extended Kalman Filter system dynamics linearized handle potential non-linearities. computationally fastest method. (Continous-Discrete) Unscented Kalman Filter. higher order non-linear Kalman Filter improves mean covariance estimates system display high nonlinearity, circumvents necessity compute jacobian drift observation functions. package features currently available kalman filters, TMB limited parameter estimation. particular, straight-forward obtain k-step-ahead predictions methods (use predict S3 method), stochastic simulation also available cases long prediction horizons sought, normality assumption inaccurate. ode.solver Sets ODE solver used Kalman Filter methods solving moment differential equations. default \"euler\" Forward Euler method, alternatively classical 4th order Runge Kutta method available via \"rk4\". ode.timestep numeric value. Sets time step-size numerical filtering schemes. defined step-size used calculate number steps observation time-points defined provided data. calculated number steps larger N.01 N integer, time-step reduced exactly N+1 steps taken observations step-size used two following ways depending chosen method: Kalman filters: time-step used step-size numerical Forward-Euler scheme compute prior state mean covariance estimate final time solution first second order moment differential equations. TMB method: time-step used step-size Euler-Maruyama scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. loss character vector. Sets loss function type (implemented kalman filter methods). loss function per default quadratic one-step residauls natural Gaussian (negative log) likelihood evaluated, tails distribution considered small .e. outliers weighted much, one can choose loss functions accounts . three available types available: Quadratic loss (quadratic). Quadratic-Linear (huber) Quadratic-Constant (tukey) cutoff Huber Tukey loss functions determined provided cutoff parameter loss_c. implementations losses approximations (pseudo-huber sigmoid approxmation respectively) smooth derivatives. loss_c cutoff value huber tukey loss functions. Defaults c=3 compile boolean value. default (FALSE) compile C++ objective function assume already compiled corresponds specified model object. user's responsibility ensure correspondence specified model precompiled C++ object. precompiled C++ object found specified directory .e. <cppfile_directory>/<modelname>/(dll/) compile flag set TRUE. user makes changes system equations, observation equations, observation variances, algebraic relations lamperi transformations C++ object recompiled. silent logical value whether suppress printed messages 'Checking Data', 'Building Model', etc. Default behaviour (FALSE) print messages.","code":""},{"path":"/reference/ctsmrTMB.html","id":"method-estimate-","dir":"Reference","previous_headings":"","what":"Method estimate()","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"Estimate fixed effects parameters specified model.","code":""},{"path":"/reference/ctsmrTMB.html","id":"usage-19","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"","code":"ctsmrTMB$estimate(   data,   method = \"ekf\",   ode.solver = \"euler\",   ode.timestep = min(diff(data$t)),   loss = \"quadratic\",   loss_c = 3,   use.hessian = FALSE,   compile = FALSE,   control = list(trace = 1),   silent = FALSE )"},{"path":"/reference/ctsmrTMB.html","id":"arguments-13","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"data data.frame containing time-vector 't', observations inputs. observations can take NA-values. method character vector - one either \"ekf\", \"ukf\" \"tmb\". Sets estimation method. package three available methods implemented: natural TMB-style formulation latent states considered random effects integrated using Laplace approximation. method yields gradient (negative log) likelihood function respect fixed effects optimization. method slower although probably precision advantages, allows non-Gaussian observation noise (yet implemented). One-step / K-step residuals yet available package. (Continous-Discrete) Extended Kalman Filter system dynamics linearized handle potential non-linearities. computationally fastest method. (Continous-Discrete) Unscented Kalman Filter. higher order non-linear Kalman Filter improves mean covariance estimates system display high nonlinearity, circumvents necessity compute jacobian drift observation functions. package features currently available kalman filters, TMB limited parameter estimation. particular, straight-forward obtain k-step-ahead predictions methods (use predict S3 method), stochastic simulation also available cases long prediction horizons sought, normality assumption inaccurate. ode.solver Sets ODE solver used Kalman Filter methods solving moment differential equations. default \"euler\" Forward Euler method, alternatively classical 4th order Runge Kutta method available via \"rk4\". ode.timestep numeric value. Sets time step-size numerical filtering schemes. defined step-size used calculate number steps observation time-points defined provided data. calculated number steps larger N.01 N integer, time-step reduced exactly N+1 steps taken observations step-size used two following ways depending chosen method: Kalman filters: time-step used step-size numerical Forward-Euler scheme compute prior state mean covariance estimate final time solution first second order moment differential equations. TMB method: time-step used step-size Euler-Maruyama scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. loss character vector. Sets loss function type (implemented kalman filter methods). loss function per default quadratic one-step residauls natural Gaussian (negative log) likelihood evaluated, tails distribution considered small .e. outliers weighted much, one can choose loss functions accounts . three available types available: Quadratic loss (quadratic). Quadratic-Linear (huber) Quadratic-Constant (tukey) cutoff Huber Tukey loss functions determined provided cutoff parameter loss_c. implementations losses approximations (pseudo-huber sigmoid approxmation respectively) smooth derivatives. loss_c cutoff value huber tukey loss functions. Defaults c=3 use.hessian boolean value. default (TRUE) causes optimization algorithm stats::nlminb use fixed effects hessian (negative log) likelihood performing optimization. feature available kalman filter methods without random effects. compile boolean value. default (FALSE) compile C++ objective function assume already compiled corresponds specified model object. user's responsibility ensure correspondence specified model precompiled C++ object. precompiled C++ object found specified directory .e. <cppfile_directory>/<modelname>/(dll/) compile flag set TRUE. user makes changes system equations, observation equations, observation variances, algebraic relations lamperi transformations C++ object recompiled. control list control parameters parsed nlminb control argument. See ?stats::nlminb information silent logical value whether suppress printed messages 'Checking Data', 'Building Model', etc. Default behaviour (FALSE) print messages.","code":""},{"path":"/reference/ctsmrTMB.html","id":"method-predict-","dir":"Reference","previous_headings":"","what":"Method predict()","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"Perform prediction/filtration obtain state mean covariance estimates. predictions obtained solving moment equations n.ahead steps forward time using current step posterior state estimate initial condition.","code":""},{"path":"/reference/ctsmrTMB.html","id":"usage-20","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"","code":"ctsmrTMB$predict(   data,   pars = NULL,   k.ahead = 1,   return.k.ahead = NULL,   method = \"ekf\",   ode.timestep = min(diff(data$t)),   ode.solver = \"euler\",   x0 = NULL,   p0 = NULL,   return.covariance = TRUE,   compile = FALSE,   silent = FALSE )"},{"path":"/reference/ctsmrTMB.html","id":"arguments-14","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"data data.frame containing time-vector 't', observations inputs. observations can take NA-values. pars fixed parameter vector parsed objective function prediction/filtration. default parameter values used initial parameters provided add_parameters, unless estimate function run, default values found optimum. k.ahead integer specifying desired number time-steps (determined provided data time-vector) predictions made (integrating moment ODEs forward time without data updates). return.k.ahead numeric vector integers specifying n.ahead predictions returned. method character vector - one either \"ekf\", \"ukf\" \"tmb\". Sets estimation method. package three available methods implemented: EKF IMPLEMENTED CURRENTLY!! natural TMB-style formulation latent states considered random effects integrated using Laplace approximation. method yields gradient (negative log) likelihood function respect fixed effects optimization. method slower although probably precision advantages, allows non-Gaussian observation noise (yet implemented). One-step / K-step residuals yet available package. (Continous-Discrete) Extended Kalman Filter system dynamics linearized handle potential non-linearities. computationally fastest method. (Continous-Discrete) Unscented Kalman Filter. higher order non-linear Kalman Filter improves mean covariance estimates system display high nonlinearity, circumvents necessity compute jacobian drift observation functions. package features currently available kalman filters, TMB limited parameter estimation. particular, straight-forward obtain k-step-ahead predictions methods (use predict S3 method), stochastic simulation also available cases long prediction horizons sought, normality assumption inaccurate. ode.timestep numeric value. Sets time step-size numerical filtering schemes. defined step-size used calculate number steps observation time-points defined provided data. calculated number steps larger N.01 N integer, time-step reduced exactly N+1 steps taken observations step-size used two following ways depending chosen method: Kalman filters: time-step used step-size numerical Forward-Euler scheme compute prior state mean covariance estimate final time solution first second order moment differential equations. TMB method: time-step used step-size Euler-Maruyama scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. ode.solver Sets ODE solver used Kalman Filter methods solving moment differential equations. default \"euler\" Forward Euler method, alternatively classical 4th order Runge Kutta method available via \"rk4\". x0 numeric vector containing initial expected state values p0 numeric matrix contianing initial state covariances return.covariance booelan value indicate whether covariance (instead correlation) returned. compile boolean value. default (FALSE) compile C++ objective function assume already compiled corresponds specified model object. user's responsibility ensure correspondence specified model precompiled C++ object. precompiled C++ object found specified directory .e. <cppfile_directory>/<modelname>/(dll/) compile flag set TRUE. user makes changes system equations, observation equations, observation variances, algebraic relations lamperi transformations C++ object recompiled. silent logical value whether suppress printed messages 'Checking Data', 'Building Model', etc. Default behaviour (FALSE) print messages.","code":""},{"path":"/reference/ctsmrTMB.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"data.frame contains time step posterior state estimate time.step (k = 0), prior state predictions (k = 1,...,n.ahead). return.covariance = TRUE state covariance/correlation matrix returned, otherwise marginal variances returned.","code":""},{"path":"/reference/ctsmrTMB.html","id":"method-print-","dir":"Reference","previous_headings":"","what":"Method print()","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"Function print model object","code":""},{"path":"/reference/ctsmrTMB.html","id":"usage-21","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"","code":"ctsmrTMB$print()"},{"path":"/reference/ctsmrTMB.html","id":"method-summary-","dir":"Reference","previous_headings":"","what":"Method summary()","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"Summary function fit","code":""},{"path":"/reference/ctsmrTMB.html","id":"usage-22","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"","code":"ctsmrTMB$summary(correlation = FALSE)"},{"path":"/reference/ctsmrTMB.html","id":"arguments-15","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"correlation boolean value. default (FALSE) provide fixed effects parameter correlation matrix.","code":""},{"path":"/reference/ctsmrTMB.html","id":"method-plot-","dir":"Reference","previous_headings":"","what":"Method plot()","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"Function print model object","code":""},{"path":"/reference/ctsmrTMB.html","id":"usage-23","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"","code":"ctsmrTMB$plot(   plot.obs = 1,   pacf = FALSE,   extended = FALSE,   ggtheme = getggplot2theme() )"},{"path":"/reference/ctsmrTMB.html","id":"arguments-16","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"plot.obs vector indicate observations plotted . multiple chosen list plots observation returned. pacf logical indicate whether partial autocorrelations returned. default FALSE case histogram returned instead. extended logical. TRUE additional information printed ggtheme ggplot2 theme use creating ggplot.","code":""},{"path":"/reference/ctsmrTMB.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"objects class cloneable method.","code":""},{"path":"/reference/ctsmrTMB.html","id":"usage-24","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"","code":"ctsmrTMB$clone(deep = FALSE)"},{"path":"/reference/ctsmrTMB.html","id":"arguments-17","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor for R6 ctsmrTMB class — ctsmrTMB","text":"deep Whether make deep clone.","code":""},{"path":[]},{"path":"/reference/plot.ctsmrTMB.fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic summary of objects of class 'ctsmrTMB' — plot.ctsmrTMB.fit","title":"Basic summary of objects of class 'ctsmrTMB' — plot.ctsmrTMB.fit","text":"Basic summary objects class 'ctsmrTMB'","code":""},{"path":"/reference/plot.ctsmrTMB.fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic summary of objects of class 'ctsmrTMB' — plot.ctsmrTMB.fit","text":"","code":"# S3 method for ctsmrTMB.fit plot(   fit,   plot.obs = 1,   pacf = FALSE,   extended = FALSE,   ggtheme = getggplot2theme() )"},{"path":"/reference/plot.ctsmrTMB.fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Basic summary of objects of class 'ctsmrTMB' — plot.ctsmrTMB.fit","text":"plot.obs vector indicate observations plotted . multiple chosen list plots observation returned. pacf logical indicate whether partial autocorrelations returned. default FALSE case histogram returned instead. extended logical. TRUE additional information printed ggtheme ggplot2 theme use creating ggplot.","code":""},{"path":"/reference/plot.ctsmrTMB.fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic summary of objects of class 'ctsmrTMB' — plot.ctsmrTMB.fit","text":"list plots","code":""},{"path":"/reference/plot.ctsmrTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic summary of objects of class 'ctsmrTMB' — plot.ctsmrTMB","title":"Basic summary of objects of class 'ctsmrTMB' — plot.ctsmrTMB","text":"Basic summary objects class 'ctsmrTMB'","code":""},{"path":"/reference/plot.ctsmrTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic summary of objects of class 'ctsmrTMB' — plot.ctsmrTMB","text":"","code":"# S3 method for ctsmrTMB plot(   object,   plot.obs = 1,   pacf = FALSE,   extended = FALSE,   ggtheme = getggplot2theme() )"},{"path":"/reference/plot.ctsmrTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Basic summary of objects of class 'ctsmrTMB' — plot.ctsmrTMB","text":"plot.obs vector indicate observations plotted . multiple chosen list plots observation returned. pacf logical indicate whether partial autocorrelations returned. default FALSE case histogram returned instead. extended logical. TRUE additional information printed ggtheme ggplot2 theme use creating ggplot.","code":""},{"path":"/reference/plot.ctsmrTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic summary of objects of class 'ctsmrTMB' — plot.ctsmrTMB","text":"huge amount information","code":""},{"path":"/reference/plot.ctsmrTMB.pred.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic summary of objects of class 'ctsmrTMB.pred' from predict — plot.ctsmrTMB.pred","title":"Basic summary of objects of class 'ctsmrTMB.pred' from predict — plot.ctsmrTMB.pred","text":"Basic summary objects class 'ctsmrTMB.pred' predict","code":""},{"path":"/reference/plot.ctsmrTMB.pred.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic summary of objects of class 'ctsmrTMB.pred' from predict — plot.ctsmrTMB.pred","text":"","code":"# S3 method for ctsmrTMB.pred plot(pred.data, n.ahead = 0, state.name = NULL, ...)"},{"path":"/reference/plot.ctsmrTMB.pred.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic summary of objects of class 'ctsmrTMB.pred' from predict — plot.ctsmrTMB.pred","text":"huge amount information","code":""},{"path":"/reference/predict.ctsmrTMB.fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict state estimates on ctsmrTMB.fit object. — predict.ctsmrTMB.fit","title":"Predict state estimates on ctsmrTMB.fit object. — predict.ctsmrTMB.fit","text":"Predict state estimates ctsmrTMB.fit object.","code":""},{"path":"/reference/predict.ctsmrTMB.fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict state estimates on ctsmrTMB.fit object. — predict.ctsmrTMB.fit","text":"","code":"# S3 method for ctsmrTMB.fit predict(   fit,   data = NULL,   x0 = NULL,   p0 = NULL,   n.step.ahead = 1,   ode.timestep = NULL,   return.state.dispersion = FALSE,   covariance = FALSE,   give.only.n.step.ahead = FALSE,   use.simulation = FALSE,   sim.timestep = NULL,   n.sim = 100,   quantiles = c(0.05, 0.5, 0.95),   return.full.simulations = FALSE )"},{"path":"/reference/predict.ctsmrTMB.fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict state estimates on ctsmrTMB.fit object. — predict.ctsmrTMB.fit","text":"fit ctsmrTMB.fit object calling estimate method ctsmrTMB object. data data.frame used predict update model fit based. use.simulation Boolean. TRUE simulates stochastic model returns quantiles. FALSE uses returns solution values first second order moment differential equations. Default: FALSE n.sim Integer. Number simulations performed use.simulation TRUE. Default: 100 quantiles returned state distribution quantiles use.simulation TRUE. n.step Integer. Number prediction steps updating. Default: 1","code":""},{"path":"/reference/predict.ctsmrTMB.fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict state estimates on ctsmrTMB.fit object. — predict.ctsmrTMB.fit","text":"Prediction model","code":""},{"path":"/reference/predict.ctsmrTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform prediction/filtration on ctsmrTMB object. — predict.ctsmrTMB","title":"Perform prediction/filtration on ctsmrTMB object. — predict.ctsmrTMB","text":"Perform prediction/filtration ctsmrTMB object.","code":""},{"path":"/reference/predict.ctsmrTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform prediction/filtration on ctsmrTMB object. — predict.ctsmrTMB","text":"","code":"# S3 method for ctsmrTMB predict(   object,   data,   pars = NULL,   k.ahead = 1,   return.k.ahead = NULL,   method = \"ekf\",   ode.timestep = min(diff(data$t)),   ode.solver = \"euler\",   x0 = NULL,   p0 = NULL,   return.covariance = TRUE,   compile = FALSE,   silent = FALSE )"},{"path":"/reference/predict.ctsmrTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform prediction/filtration on ctsmrTMB object. — predict.ctsmrTMB","text":"data data.frame containing time-vector 't', observations inputs. observations can take NA-values. pars fixed parameter vector parsed objective function prediction/filtration. method character vector - one either \"ekf\", \"ukf\" \"tmb\". Sets estimation method. package three available methods implemented: EKF IMPLEMENTED CURRENTLY!! natural TMB-style formulation latent states considered random effects integrated using Laplace approximation. method yields gradient (negative log) likelihood function respect fixed effects optimization. method slower although probably precision advantages, allows non-Gaussian observation noise (yet implemented). One-step / K-step residuals yet available package. (Continous-Discrete) Extended Kalman Filter system dynamics linearized handle potential non-linearities. computationally fastest method. (Continous-Discrete) Unscented Kalman Filter. higher order non-linear Kalman Filter improves mean covariance estimates system display high nonlinearity, circumvents necessity compute jacobian drift observation functions. package features currently available kalman filters, TMB limited parameter estimation. particular, straight-forward obtain k-step-ahead predictions methods (use predict S3 method), stochastic simulation also available cases long prediction horizons sought, normality assumption inaccurate. ode.timestep numeric value. Sets time step-size numerical filtering schemes. defined step-size used calculate number steps observation time-points defined provided data. calculated number steps larger N.01 N integer, time-step reduced exactly N+1 steps taken observations step-size used two following ways depending chosen method: Kalman filters: time-step used step-size numerical Forward-Euler scheme compute prior state mean covariance estimate final time solution first second order moment differential equations. TMB method: time-step used step-size Euler-Maruyama scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. return.covariance booelan value indicate whether covariance (instead correlation) returned. compile boolean value. default (FALSE) compile C++ objective function assume already compiled corresponds specified model object. user's responsibility ensure correspondence specified model precompiled C++ object. precompiled C++ object found specified directory .e. <cppfile_directory>/<modelname>/(dll/) compile flag set TRUE. user makes changes system equations, observation equations, observation variances, algebraic relations lamperi transformations C++ object recompiled. n.ahead integer specifying desired number time-steps (determined provided data time-vector) predictions made (integrating moment ODEs forward time without data updates).","code":""},{"path":"/reference/predict.ctsmrTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform prediction/filtration on ctsmrTMB object. — predict.ctsmrTMB","text":"State estimates covariance/correlations","code":""},{"path":"/reference/print.ctsmrTMB.fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic print of objects of class 'ctsmrTMB' — print.ctsmrTMB.fit","title":"Basic print of objects of class 'ctsmrTMB' — print.ctsmrTMB.fit","text":"Basic print objects class 'ctsmrTMB'","code":""},{"path":"/reference/print.ctsmrTMB.fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic print of objects of class 'ctsmrTMB' — print.ctsmrTMB.fit","text":"","code":"# S3 method for ctsmrTMB.fit print(fit)"},{"path":"/reference/print.ctsmrTMB.fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic print of objects of class 'ctsmrTMB' — print.ctsmrTMB.fit","text":"huge amount information","code":""},{"path":"/reference/print.ctsmrTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic print of objects of class 'ctsmrTMB' — print.ctsmrTMB","title":"Basic print of objects of class 'ctsmrTMB' — print.ctsmrTMB","text":"Basic print objects class 'ctsmrTMB'","code":""},{"path":"/reference/print.ctsmrTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic print of objects of class 'ctsmrTMB' — print.ctsmrTMB","text":"","code":"# S3 method for ctsmrTMB print(object, ...)"},{"path":"/reference/print.ctsmrTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic print of objects of class 'ctsmrTMB' — print.ctsmrTMB","text":"huge amount information","code":""},{"path":"/reference/summary.ctsmrTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic summary of objects of class 'ctsmrTMB' — summary.ctsmrTMB","title":"Basic summary of objects of class 'ctsmrTMB' — summary.ctsmrTMB","text":"Basic summary objects class 'ctsmrTMB'","code":""},{"path":"/reference/summary.ctsmrTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic summary of objects of class 'ctsmrTMB' — summary.ctsmrTMB","text":"","code":"# S3 method for ctsmrTMB summary(object, correlation = FALSE)"},{"path":"/reference/summary.ctsmrTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic summary of objects of class 'ctsmrTMB' — summary.ctsmrTMB","text":"huge amount information","code":""},{"path":"/news/index.html","id":"ctsmrtmb-05","dir":"Changelog","previous_headings":"","what":"ctsmrTMB 0.5","title":"ctsmrTMB 0.5","text":"first release package","code":""}]
